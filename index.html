<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>BF6 Ranked System</title>

<!-- ============================= -->
<!-- ===== GLOBAL STYLES (CSS) === -->
<!-- ============================= -->
<style>


  /* ====== FORM (ADD MATCH) ====== */
.form .grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 12px;
  max-width: 620px;
}

.form label{
  display:flex;
  flex-direction:column;
  gap: 8px;
  font-size: 12px;
  color:#cbd5e1;
  letter-spacing: .3px;
}

.form input[type="number"]{
  padding: 12px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(2,6,23,0.55);
  color:#e5e7eb;
  outline: none;
}

.form input[type="number"]:focus{
  border-color: rgba(34,211,238,0.35);
  box-shadow: 0 0 18px rgba(34,211,238,0.08);
}

.toggles{
  margin-top: 14px;
  display:flex;
  gap: 12px;
  flex-wrap: wrap;
}

.toggle{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(2,6,23,0.45);
  color:#e5e7eb;
  font-size: 12px;
}

.toggle input{ transform: scale(1.1); }

.actions{
  margin-top: 16px;
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap: wrap;
}

.btn{
  padding: 10px 14px;
  border-radius: 12px;
  border: 1px solid rgba(34,211,238,0.35);
  background: rgba(34,211,238,0.14);
  color:#a5f3fc;
  cursor:pointer;
  font-weight: 700;
  letter-spacing: .3px;
}

.btn:hover{
  background: rgba(34,211,238,0.22);
}

.btn.ghost{
  border-color: rgba(251,113,133,0.35);
  background: rgba(251,113,133,0.10);
  color:#fecdd3;
}

.btn.ghost:hover{
  background: rgba(251,113,133,0.16);
}

.hint{
  font-size: 12px;
  color:#9ca3af;
  opacity: .9;
}

  /* ====== MATCH HISTORY UI ====== */
.history-top{
  margin-top: 22px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  max-width: 900px;
}
  .season-summary{
  margin-top: 14px;
  max-width: 1100px;
  background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(2,6,23,.9));
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 14px;
  padding: 14px 16px;
  box-shadow: 0 0 24px rgba(34,211,238,0.05);
}

.season-summary .row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
  padding: 6px 0;
  border-bottom: 1px solid rgba(255,255,255,0.06);
}

.season-summary .row:last-child{ border-bottom:none; }

.season-summary .k{
  color:#9ca3af;
  font-size: 12px;
  letter-spacing: .4px;
}

.season-summary .v{
  color:#e5e7eb;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: .4px;
}

.season-tag{
  display:inline-block;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(2,6,23,0.55);
  font-size: 11px;
  color:#cbd5e1;
}
.season-tag.active{
  border-color: rgba(34,211,238,0.30);
  color:#a5f3fc;
}
  .history-controls{
  margin-top: 16px;
  max-width: 900px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
}
  .season-select{
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(2,6,23,0.55);
  color:#e5e7eb;
  outline:none;
  font-size: 12px;
}
  .ro-badge{
  display:inline-block;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.78);
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .12em;
}
  
.season-select:focus{
  border-color: rgba(34,211,238,0.35);
  box-shadow: 0 0 18px rgba(34,211,238,0.08);
}

.mini-card{
  padding: 14px 16px;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(2,6,23,.9));
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 0 24px rgba(34,211,238,0.05);
}

.mini-label{
  font-size: 12px;
  color:#9ca3af;
  letter-spacing: .8px;
}

.mini-value{
  margin-top: 6px;
  font-size: 22px;
  font-weight: 800;
  color:#22d3ee;
  text-shadow: 0 0 10px rgba(34,211,238,0.25);
}

.match-list{
  margin-top: 16px;
  display: grid;
  gap: 12px;
  max-width: 900px;
}

.match-card{
  position: relative;
  padding: 16px 16px;
  border-radius: 16px;
  background: linear-gradient(135deg, rgba(2,6,23,.85), rgba(15,23,42,.85));
  border: 1px solid rgba(255,255,255,0.06);
  overflow: hidden;
  transition: transform .2s ease, border-color .2s ease, box-shadow .2s ease;
}

.match-card:hover{
  transform: translateY(-1px);
  border-color: rgba(34,211,238,0.18);
  box-shadow: 0 0 28px rgba(34,211,238,0.06);
}

.match-card.best{
  border-color: rgba(34,211,238,0.55);
  box-shadow: 0 0 34px rgba(34,211,238,0.10);
}

.match-card.worst{
  border-color: rgba(251,113,133,0.45);
  box-shadow: 0 0 34px rgba(251,113,133,0.08);
}

.match-row{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.left{
  display:flex;
  flex-direction: column;
  gap: 6px;
}

.title{
  display:flex;
  align-items:center;
  gap:10px;
  font-weight: 800;
  letter-spacing: .8px;
}

.place{
  font-size: 12px;
  color:#9ca3af;
}

.kad{
  font-size: 12px;
  color:#9ca3af;
}
  .breakdown{
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.06);
  background: rgba(2,6,23,0.42);
}

.break-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  font-size: 12px;
  color:#9ca3af;
  padding: 2px 0;
}

.break-row strong{
  color:#e5e7eb;
  font-weight: 800;
}

.break-row .pos{ color: #22c55e; }
.break-row .neg{ color: #fb7185; }

.break-total{
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid rgba(255,255,255,0.06);
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-size: 12px;
  letter-spacing: .4px;
}

.break-total span{
  color:#cbd5e1;
  font-weight: 800;
}

.rpDelta{
  font-size: 18px;
  font-weight: 900;
  min-width: 90px;
  text-align: right;
}
  .match-actions{
  display:flex;
  gap:8px;
  justify-content:flex-end;
  margin-top:10px;
}

.btn-mini{
  padding: 6px 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.85);
  cursor: pointer;
  font-size: 12px;
  font-weight: 700;
}

.btn-mini:hover{
  background: rgba(255,255,255,0.10);
  border-color: rgba(255,255,255,0.18);
}

.btn-mini.danger{
  border-color: rgba(251,113,133,0.35);
  background: rgba(251,113,133,0.10);
  color:#fecdd3;
}
.btn-mini.danger:hover{
  background: rgba(251,113,133,0.16);
}

.rpPlus{ color:#22c55e; text-shadow: 0 0 12px rgba(34,197,94,0.15); }
.rpMinus{ color:#fb7185; text-shadow: 0 0 12px rgba(251,113,133,0.15); }

.badges{
  display:flex;
  gap:8px;
  flex-wrap: wrap;
}

.badge-pill{
  font-size: 11px;
  letter-spacing: .6px;
  padding: 5px 9px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(2,6,23,0.55);
  color:#e5e7eb;
  opacity: .95;
}

.badge-mvp{
  border-color: rgba(251,191,36,0.35);
  box-shadow: 0 0 14px rgba(251,191,36,0.10);
  color:#fbbf24;
}

.badge-leave{
  border-color: rgba(251,113,133,0.35);
  box-shadow: 0 0 14px rgba(251,113,133,0.10);
  color:#fb7185;
}

  /* ====== RANK LADDER ====== */
.ladder{
  margin-top: 28px;
  max-width: 1100px;
  margin: 28px auto 0;
}

.ladder-head{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  margin-bottom: 12px;
}

.ladder-head h3{
  font-size: 18px;
  letter-spacing: .6px;
  color:#e5e7eb;
}

.ladder-note{
  font-size: 12px;
  color:#9ca3af;
  opacity:.9;
}

.ladder-list{
  display: grid;
  gap: 14px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.ladder-item{
  position:relative;
  display:flex;
  gap: 14px;
  align-items:center;
  padding: 14px 16px;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(2,6,23,.9));
  border: 1px solid rgba(255,255,255,0.06);
  overflow:hidden;
  transition: transform .2s ease, border-color .2s ease, box-shadow .2s ease;
}

.ladder-item:hover{
  transform: translateY(-1px);
  border-color: rgba(34,211,238,0.18);
  box-shadow: 0 0 26px rgba(34,211,238,0.06);
}

.ladder-item.locked{
  opacity: .35;
  filter: grayscale(0.35);
}

.ladder-item.unlocked{
  opacity: 1;
}

.ladder-item.current{
  border-color: rgba(34,211,238,0.55);
  box-shadow: 0 0 34px rgba(34,211,238,0.10);
}

.ladder-item.current::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius: 14px;
  padding: 2px;
  background: linear-gradient(120deg, rgba(34,211,238,0.95), rgba(56,189,248,0.0), rgba(34,211,238,0.75));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: .55;
  filter: drop-shadow(0 0 14px rgba(34,211,238,0.25));
  pointer-events:none;
}

.badge{
  width: 56px;
  height: 56px;
  border-radius: 16px;
  position:relative;
  overflow:hidden;
  box-shadow: 0 0 16px rgba(0,0,0,.35);
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: transparent;
}
  /* Ladder badge states (images) */
.ladder-item.locked .badge{
  filter: grayscale(1) brightness(0.35);
  opacity: 0.35;
}

.ladder-item.unlocked .badge{
  filter: grayscale(0.15) brightness(0.9);
  opacity: 0.9;
}

.ladder-item.current .badge{
  filter: grayscale(0) brightness(1.05);
  opacity: 1;
}

.badge::before{
  content:"";
  position:absolute;
  inset:-16px;
  background: conic-gradient(from 0deg, rgba(255,255,255,0.0), rgba(255,255,255,0.55), rgba(255,255,255,0.0));
  opacity:.25;
  animation: spin 7s linear infinite;
}

.meta .name{
  font-size: 14px;
  letter-spacing: 1px;
  font-weight: 700;
  color:#e5e7eb;
}

.meta .desc{
  margin-top: 2px;
  font-size: 12px;
  color:#9ca3af;
}
  @media (max-width: 980px){
  .ladder-list{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}
@media (max-width: 640px){
  .ladder-list{ grid-template-columns: 1fr; }
}

/* ====== BADGE COLORS (Neon identity) ====== */
.b-outcast   { background: radial-gradient(circle at 30% 30%, #ffb86b, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(255,146,76,.35); }
.b-vanguard  { background: radial-gradient(circle at 30% 30%, #22d3ee, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(34,211,238,.35); }
.b-sentinel  { background: radial-gradient(circle at 30% 30%, #38bdf8, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(56,189,248,.35); }
.b-phantom   { background: radial-gradient(circle at 30% 30%, #a78bfa, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(167,139,250,.35); }
.b-warlord   { background: radial-gradient(circle at 30% 30%, #fb7185, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(251,113,133,.35); }
.b-archon    { background: radial-gradient(circle at 30% 30%, #fbbf24, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(251,191,36,.35); }
.b-overseer  { background: radial-gradient(circle at 30% 30%, #2dd4bf, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(45,212,191,.35); }
.b-ascendant { background: radial-gradient(circle at 30% 30%, #60a5fa, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(96,165,250,.35); }
.b-paragon   { background: radial-gradient(circle at 30% 30%, #e5e7eb, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(229,231,235,.25); }
.b-nexus     { background: radial-gradient(circle at 30% 30%, #ff3b3b, #0b0f1a 55%, #020617 85%); box-shadow: 0 0 22px rgba(255,59,59,.40); }

.ladder-item.nexus{
  border-color: rgba(255,59,59,0.25);
}

/* ====== GLOBAL ====== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Segoe UI', sans-serif;
}

body {
  background: radial-gradient(circle at top, #0b0f1a, #05070d);
  color: #e5e7eb;
  min-height: 100vh;
}

/* ====== NAV BAR ====== */
.navbar {
  display: flex;
  justify-content: center;
  gap: 30px;
  padding: 20px;
  background: linear-gradient(180deg, #0f172a, #020617);
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.nav-btn {
  background: transparent;
  border: none;
  color: #9ca3af;
  font-size: 15px;
  letter-spacing: 1px;
  cursor: pointer;
  padding: 10px 20px;
  position: relative;
  transition: color 0.3s;
}

.nav-btn:hover { color: #38bdf8; }
.nav-btn.active { color: #22d3ee; }

.nav-btn.active::after {
  content: '';
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40%;
  height: 2px;
  background: linear-gradient(90deg, #22d3ee, #38bdf8);
  box-shadow: 0 0 12px #22d3ee;
}

/* ====== CONTENT ====== */
.section {
  display: none;
  padding: 50px;
  animation: fade 0.4s ease;
  max-width: 1200px;
  margin: 0 auto;
}
.section.active { display: block; }

@keyframes fade {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ====== HEADERS ====== */
h1 {
  font-size: 32px;
  margin-bottom: 10px;
  background: linear-gradient(90deg, #22d3ee, #38bdf8);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

p { color: #9ca3af; }

/* ====== PANELS ====== */
.panel {
  margin-top: 30px;
  background: linear-gradient(180deg, #0f172a, #020617);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 14px;
  padding: 25px;
  box-shadow: 0 0 25px rgba(34,211,238,0.05);
}

/* ====== RANK CARD (BASE) ====== */
.rank-card {
  margin-top: 40px;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  gap: 18px;
  padding: 40px 28px;
  background: linear-gradient(135deg, #020617, #0f172a);
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 0 40px rgba(56,189,248,0.15);
  width: 100%;
max-width: 1100px;
margin: 32px auto 20px;

  position: relative;
  overflow: hidden;
  transition: transform 0.25s ease;
}

.rank-card:hover { transform: translateY(-2px); }

.rank-icon {
  width: 260px;
  height: 260px;
  border-radius: 50%;
  position: relative;
  overflow: hidden;
  box-shadow: 0 0 25px color-mix(in srgb, var(--rank-accent, #22d3ee) 75%, transparent);
  background: transparent;
}
  .rank-icon img{
  position: absolute;
  inset: 10px;
  width: calc(100% - 20px);
  height: calc(100% - 20px);
  object-fit: contain;
  z-index: 2;
  pointer-events: none;
  filter: drop-shadow(0 0 18px rgba(255,255,255,0.35));
}

.rank-glow {
  position: absolute;
  inset: -20px;
  background: conic-gradient(from 0deg, transparent, #38bdf8, transparent);
  animation: spin 6s linear infinite;
  z-index: 1;
  pointer-events: none;
}

@keyframes spin { to { transform: rotate(360deg); } }

.rank-info h2 {
  font-size: 44px;
  letter-spacing: 1.2px;
  margin-bottom: 8px;
  background: linear-gradient(90deg, #38bdf8, #22d3ee);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.rank-rp { font-size: 16px; color: #cbd5e1; }

/* ====== RP BAR ====== */
.rp-bar {
  margin: 14px auto 0;
  width: min(520px, 92vw);
  height: 12px;
  background: #020617;
  border-radius: 10px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.08);
}

.rp-fill {
  height: 100%;
  background: linear-gradient(90deg, #22d3ee, #38bdf8, #0ea5e9);
  box-shadow: 0 0 12px #38bdf8;
  transition: width 0.5s ease;
}

/* ====== CHIP ====== */
.chip{
  display:inline-block;
  margin-top:10px;
  padding:6px 10px;
  font-size:12px;
  letter-spacing:1px;
  color:#a5f3fc;
  border:1px solid rgba(34,211,238,0.35);
  border-radius:999px;
  background: rgba(2,6,23,0.55);
  box-shadow: 0 0 14px rgba(34,211,238,0.15);
}

/* ====== RANK CARD GAME FX ====== */
.rank-bg {
  position: absolute;
  inset: -40px;
  background:
    radial-gradient(circle at 20% 30%, rgba(34,211,238,0.25), transparent 55%),
    radial-gradient(circle at 80% 70%, rgba(56,189,248,0.18), transparent 60%),
    radial-gradient(circle at 50% 50%, rgba(14,165,233,0.12), transparent 65%);
  filter: blur(12px);
  animation: bgFloat 8s ease-in-out infinite;
  z-index: 0;
}

@keyframes bgFloat {
  0% { transform: translate(0,0) scale(1); }
  50% { transform: translate(12px,-8px) scale(1.03); }
  100% { transform: translate(0,0) scale(1); }
}

.rank-noise {
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='260' height='260'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='260' height='260' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
  opacity: 0.12;
  mix-blend-mode: overlay;
  z-index: 1;
}

.rank-card::after {
  content: "";
  position: absolute;
  inset: -2px;
  border-radius: 18px;
  padding: 2px;
  background: linear-gradient(120deg, rgba(34,211,238,0.9), rgba(56,189,248,0.0), rgba(34,211,238,0.7));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.55;
  filter: drop-shadow(0 0 18px rgba(34,211,238,0.35));
  animation: edgePulse 3.2s ease-in-out infinite;
  z-index: 2;
}

@keyframes edgePulse {
  0%, 100% { opacity: 0.35; }
  50% { opacity: 0.75; }
}

/* make inner content above effects */
.rank-icon, .rank-info { position: relative; z-index: 3; }

.rank-icon::before {
  content: "";
  position: absolute;
  inset: -18px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(34,211,238,0.35), transparent 65%);
  filter: blur(10px);
  opacity: 0.9;
}

.rank-icon::after {
  content: "";
  position: absolute;
  inset: 10px;
  border-radius: 50%;
  background: radial-gradient(circle at 25% 25%, rgba(255,255,255,0.35), transparent 55%);
  opacity: 0.7;
}
  
  /* ===== Digital Rift Protocol (Desktop) ===== */
:root{
  --ru-bg:#070A12;
  --ru-ink:#EAF2FF;
  --ru-muted:#98A2B3;

  --ru-c1:#23f3ff;   /* cyan */
  --ru-c2:#a855ff;   /* purple */
  --ru-c3:#ff3df2;   /* magenta */

  --ru-border: rgba(234,242,255,.12);
  --ru-glow: 0 0 18px rgba(35,243,255,.55), 0 0 42px rgba(168,85,255,.25);
}

/* Overlay container:
   Expect integration that toggles:
   - .rankup.is-open (opacity/pointer-events)
   - #rankup[data-phase="open|collapse|impact|reveal|done"] */
.rankup{
  position:fixed; inset:0; z-index:9999;
  display:grid; place-items:center;
  opacity:0; pointer-events:none;
  transition: opacity .25s ease;
}
.rankup.is-open{ opacity:1; pointer-events:auto; }

/* Veil + grain */
.rankup__veil{
  position:absolute; inset:0;
  background: radial-gradient(900px 520px at 50% 40%, rgba(0,0,0,.35), rgba(0,0,0,.90));
  opacity:0;
  filter: saturate(0.9);
}
.rankup.is-open .rankup__veil{ animation: ruVeilIn .35s ease forwards; }
@keyframes ruVeilIn{ to{ opacity:1; } } /* ok */
  animation: ruVeilIn .25s ease forwards;

.rankup__grain{
  position:absolute; inset:-20%;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
  mix-blend-mode:overlay;
  opacity:0;
  pointer-events:none;
}
.rankup.is-open .rankup__grain{ animation: ruGrainIn .35s ease .05s forwards; }
@keyframes ruGrainIn{ to{ opacity:.18; } }

/* Stage */
.rankup__stage{
  position:relative;
  width:min(900px, 92vw);
  height:min(520px, 76vh);
  border-radius:28px;
  overflow:hidden;
  background: radial-gradient(900px 520px at 50% 45%, rgba(35,243,255,.06), rgba(0,0,0,0) 60%),
            radial-gradient(900px 520px at 50% 55%, rgba(168,85,255,.05), rgba(0,0,0,0) 65%),
            rgba(7,10,18,0.55);
  border: 1px solid rgba(255,255,255,0.05);
  box-shadow: 0 70px 200px rgba(0,0,0,0.78);
  transform: translateY(14px) scale(.98);
  opacity:0;
  will-change: transform, opacity;
  outline: 1px solid rgba(255,255,255,0.04);
  backdrop-filter: none;
}
.rankup.is-open .rankup__stage{ animation: ruStageIn .55s cubic-bezier(.2,.9,.2,1) .05s forwards; }
@keyframes ruStageIn{
  to{ opacity:1; transform: translateY(0) scale(1); }
}

/* Background scanlines */
.rankup__scan{
  position:absolute; inset:0;
  background:
    linear-gradient(90deg, rgba(35,243,255,.08), transparent 40%),
    repeating-linear-gradient(180deg, rgba(234,242,255,.08) 0, rgba(234,242,255,.08) 1px, transparent 1px, transparent 11px);
  opacity:.12;
  mix-blend-mode:overlay;
  animation: ruScanMove 3.2s linear infinite;
  pointer-events:none;
}
@keyframes ruScanMove{ to{ background-position: 220px 0, 0 140px; } }

/* HUD */
.rankup__hud{
  position:absolute; left:24px; right:24px; top:20px;
  display:flex; align-items:flex-start; justify-content:space-between;
  pointer-events:none;
  opacity:.92;
}
.rankup__kicker{
  font-size:14px;
  letter-spacing:.22em;
  text-transform:uppercase;
  color:rgba(234,242,255,.85);
}
.rankup__sub{
  margin-top:8px;
  font-size:12px;
  color:rgba(152,162,179,.9);
  letter-spacing:.06em;
}
.rankup__hudRight{
  text-align:right;
  font-size:12px;
  color:rgba(234,242,255,.72);
  letter-spacing:.1em;
  text-transform:uppercase;
}

/* Rift */
.rankup__riftWrap{
  position:absolute; inset:0;
  display:grid; place-items:center;
  pointer-events:none;
}
.rankup__rift{
  position:relative;
  width:min(420px, 66vw);
  height:min(520px, 76vh);
  opacity:0;
  transform: translateY(10px) scaleX(.65) scaleY(.92) skewX(-8deg);
  will-change: transform, opacity;
  filter: drop-shadow(0 0 18px rgba(35,243,255,.45)) drop-shadow(0 0 40px rgba(168,85,255,.25));
}
.rankup__rift::before{
  content:"";
  position:absolute; inset:0;
  background:
    radial-gradient(160px 240px at 50% 50%, rgba(35,243,255,.25), transparent 60%),
    radial-gradient(240px 280px at 50% 50%, rgba(168,85,255,.22), transparent 65%),
    linear-gradient(90deg, transparent, rgba(255,255,255,.10), transparent);
  border-radius:999px;
  clip-path: polygon(46% 0, 54% 0, 58% 8%, 62% 16%, 56% 28%, 66% 40%, 54% 54%, 62% 66%, 52% 80%, 58% 92%, 54% 100%, 46% 100%, 42% 92%, 48% 80%, 38% 66%, 46% 54%, 34% 40%, 44% 28%, 38% 16%, 42% 8%);
  transform: skewX(-6deg) scaleY(.95);
  opacity:.95;
}
.rankup__rift::after{
  content:"";
  position:absolute; inset:-16%;
  background: conic-gradient(from 90deg,
    rgba(35,243,255,.0),
    rgba(35,243,255,.55),
    rgba(168,85,255,.0),
    rgba(255,61,242,.35),
    rgba(35,243,255,.0)
  );
  border-radius:999px;
  filter: blur(14px);
  opacity:.65;
  animation: ruRiftSpin 2.8s linear infinite;
}
@keyframes ruRiftSpin{ to{ transform: rotate(360deg); } }

.rankup__riftEdge{
  position:absolute; inset:-8% -18%;
  background:
    repeating-linear-gradient(90deg, rgba(35,243,255,.0) 0, rgba(35,243,255,.0) 18px, rgba(35,243,255,.22) 19px, rgba(35,243,255,.0) 24px),
    repeating-linear-gradient(180deg, rgba(255,61,242,.0) 0, rgba(255,61,242,.0) 10px, rgba(255,61,242,.18) 11px, rgba(255,61,242,.0) 18px);
  mix-blend-mode:screen;
  opacity:0;
  filter: blur(.4px);
  will-change: opacity, transform;
}

/* Emblems */
.rankup__emblems{
  position:absolute; inset:0;
  display:grid; place-items:center;
  pointer-events:none;
}
.rankup__emblem{
  width:220px; height:220px;
  border-radius:26px;
  display:grid; place-items:center;
  position:absolute;
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  border:1px solid rgba(234,242,255,.14);
  backdrop-filter: blur(6px);
  will-change: transform, opacity, filter;
}
.rankup__badge{
  width:150px; height:150px;
  border-radius:18px;
  background:
    radial-gradient(70px 70px at 40% 35%, rgba(35,243,255,.25), transparent 60%),
    radial-gradient(80px 80px at 65% 70%, rgba(168,85,255,.18), transparent 60%),
    linear-gradient(135deg, rgba(35,243,255,.18), rgba(255,61,242,.10));
  border:1px solid rgba(35,243,255,.22);
  box-shadow: var(--ru-glow);
  display:grid; place-items:center;
  position:relative;
  overflow:hidden;
}
.rankup__badge::after{
  content:"";
  position:absolute; inset:-60%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.35), transparent);
  transform: rotate(22deg) translateX(-45%);
  opacity:.15;
  animation: ruSheen 2.8s ease-in-out infinite;
}
@keyframes ruSheen{
  0%,55%{ transform: rotate(22deg) translateX(-45%); opacity:.15;}
  75%{ opacity:.55; }
  100%{ transform: rotate(22deg) translateX(45%); opacity:.12;}
}
.rankup__badge--new{
  border-color: rgba(168,85,255,.32);
  box-shadow: 0 0 18px rgba(168,85,255,.35), 0 0 42px rgba(35,243,255,.20);
}
.rankup__label{
  font-weight:800;
  letter-spacing:.14em;
  font-size:18px;
  text-transform:uppercase;
  text-shadow: 0 0 16px rgba(35,243,255,.35);
}

/* New emblem starts hidden (revealed later) */
.rankup__emblem--new{
  opacity:0;
  transform: translateY(22px) scale(.78);
  filter: blur(.6px) drop-shadow(0 0 26px rgba(168,85,255,.25));
}

/* Burst */
.rankup__burst{
  position:absolute; inset:-30%;
  background:
    radial-gradient(closest-side at 50% 50%, rgba(255,255,255,.22), transparent 60%),
    radial-gradient(closest-side at 50% 50%, rgba(35,243,255,.18), transparent 70%),
    radial-gradient(closest-side at 50% 50%, rgba(168,85,255,.16), transparent 75%);
  opacity:0;
  transform: scale(.75);
  mix-blend-mode:screen;
  pointer-events:none;
  will-change: transform, opacity;
}
  /* Flash (impact) */
.rankup__flash{
  position:absolute;
  inset:0;
  background:
    radial-gradient(closest-side at 50% 45%, rgba(255,255,255,.48), transparent 60%),
    radial-gradient(closest-side at 50% 55%, rgba(35,243,255,.24), transparent 70%),
    radial-gradient(closest-side at 50% 55%, rgba(168,85,255,.20), transparent 75%);
  opacity:0;
  mix-blend-mode:screen;
  pointer-events:none;
  will-change: opacity;
}
  /* =========================
   EPIC FX LAYERS (lightweight)
   ========================= */

.rankup__beams,
.rankup__chroma,
.rankup__shards{
  position:absolute;
  inset:0;
  pointer-events:none;
  opacity:0;
  will-change: opacity, transform;
}

/* BEAMS: depth rays */
.rankup__beams{
  background:
    conic-gradient(from 180deg,
      transparent 0deg,
      rgba(35,243,255,.10) 20deg,
      transparent 55deg,
      rgba(168,85,255,.08) 110deg,
      transparent 360deg
    ),
    radial-gradient(600px 340px at 50% 45%,
      rgba(35,243,255,.10),
      transparent 60%
    );
  mix-blend-mode: screen;
  transform: scale(.98) rotate(0deg);
}

/* CHROMA: RGB split glitch (impact only) */
.rankup__chroma{
  background:
    radial-gradient(closest-side at 50% 50%, rgba(255,0,255,.14), transparent 62%),
    radial-gradient(closest-side at 50% 50%, rgba(0,255,255,.12), transparent 68%),
    radial-gradient(closest-side at 50% 50%, rgba(255,255,255,.10), transparent 72%);
  mix-blend-mode: screen;
  transform: translate3d(0,0,0);
}

/* SHARDS: thin lines flying toward rift */
.rankup__shards{
  background:
    repeating-linear-gradient(90deg,
      rgba(35,243,255,0) 0,
      rgba(35,243,255,0) 18px,
      rgba(35,243,255,.18) 19px,
      rgba(35,243,255,0) 28px
    ),
    repeating-linear-gradient(180deg,
      rgba(255,61,242,0) 0,
      rgba(255,61,242,0) 12px,
      rgba(255,61,242,.12) 13px,
      rgba(255,61,242,0) 22px
    );
  mix-blend-mode: screen;
  transform: translate3d(0,0,0) scale(1.02);
}


/* CTA */
.rankup__cta{
  position:absolute; left:0; right:0; bottom:22px;
  display:flex; justify-content:center;
  pointer-events:auto;
  opacity:0;
  transform: translateY(10px);
  will-change: transform, opacity;
}
.rankup__btn{
  appearance:none;
  border:1px solid rgba(35,243,255,.26);
  background: linear-gradient(180deg, rgba(35,243,255,.16), rgba(168,85,255,.12));
  color:var(--ru-ink);
  padding:12px 18px;
  border-radius:16px;
  cursor:pointer;
  font-weight:700;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
.rankup__btn:hover{ border-color: rgba(35,243,255,.35); }

/* =========================
   PHASES via [data-phase="..."]
   ========================= */

/* OPEN: rift appears */
.rankup[data-phase="open"] .rankup__rift{
  animation: ruRiftOpen 1.0s cubic-bezier(.2,.9,.2,1) forwards;
}
  .rankup[data-phase="open"] .rankup__beams{
  animation: ruBeamsIn 1.05s ease forwards;
}
@keyframes ruBeamsIn{
  0%{ opacity:0; transform: scale(.98) rotate(0deg); }
  100%{ opacity:.65; transform: scale(1.02) rotate(10deg); }
}
.rankup[data-phase="open"] .rankup__riftEdge{
  animation: ruEdgeIn .7s ease .25s forwards;
}
@keyframes ruRiftOpen{
  0%{ opacity:0; transform: translateY(10px) scaleX(.65) scaleY(.92) skewX(-8deg); }
  100%{ opacity:1; transform: translateY(0) scaleX(1) scaleY(1) skewX(-6deg); }
}
@keyframes ruEdgeIn{ to{ opacity:.55; } }

/* COLLAPSE: old emblem collapses into rift */
.rankup[data-phase="collapse"] .rankup__emblem--old{
  animation: ruOldCollapse .7s cubic-bezier(.2,.9,.2,1) forwards;
}
@keyframes ruOldCollapse{
  0%{
    opacity:1;
    transform: translateY(0) scale(1) rotate(0deg);
    filter: drop-shadow(0 0 16px rgba(35,243,255,.25));
  }
  35%{
    transform: translateY(18px) scale(.92) rotate(-3deg);
  }
  70%{
    transform: translateY(46px) scale(.62) rotate(-10deg) skewX(-8deg);
    opacity:.55;
    filter: blur(1px);
  }
  100%{
    opacity:0;
    transform: translateY(86px) scale(.28) rotate(-18deg) skewX(-10deg);
    filter: blur(2px);
  }
  .rankup[data-phase="collapse"] .rankup__shards{
  animation: ruShardsPull .70s ease forwards;
}
@keyframes ruShardsPull{
  0%{ opacity:0; transform: translate3d(0,0,0) scale(1.02); }
  25%{ opacity:.65; }
  100%{ opacity:0; transform: translate3d(0,60px,0) scale(.88); }
  }
  
}

/* IMPACT: flash + shake */
.rankup[data-phase="impact"] .rankup__stage{
  animation: ruImpactShake .28s ease forwards;
}

.rankup[data-phase="impact"] .rankup__burst{
  animation: ruBurst .6s ease forwards;
}

.rankup[data-phase="impact"] .rankup__flash{
  animation: ruFlash .35s ease forwards;
}

@keyframes ruFlash{
  0%{ opacity:0; }
  22%{ opacity:1; }
  100%{ opacity:0; }
}

@keyframes ruImpactShake{
  0%{ transform: translateY(0) scale(1); }
  20%{ transform: translateY(-2px) translateX(2px) scale(1.002); }
  45%{ transform: translateY(2px) translateX(-2px) scale(1.002); }
  70%{ transform: translateY(-1px) translateX(1px) scale(1.001); }
  100%{ transform: translateY(0) translateX(0) scale(1); }
}

@keyframes ruBurst{
  0%{ opacity:0; transform: scale(.75); }
  35%{ opacity:1; transform: scale(1); }
  100%{ opacity:0; transform: scale(1.12); }
}
  .rankup[data-phase="impact"] .rankup__chroma{
  animation: ruChromaHit .22s ease forwards;
}
@keyframes ruChromaHit{
  0%{ opacity:0; transform: translate3d(0,0,0); }
  35%{ opacity:.75; transform: translate3d(8px,-2px,0); }
  100%{ opacity:0; transform: translate3d(-6px,2px,0); }
}

/* Upgrade shake to include micro-zoom + brief brightness */
@keyframes ruImpactShake{
  0%{ transform: translateY(0) scale(1); filter: brightness(1); }
  20%{ transform: translateY(-2px) translateX(2px) scale(1.012); filter: brightness(1.08); }
  45%{ transform: translateY(2px) translateX(-2px) scale(1.010); filter: brightness(1.06); }
  70%{ transform: translateY(-1px) translateX(1px) scale(1.006); filter: brightness(1.03); }
  100%{ transform: translateY(0) translateX(0) scale(1); filter: brightness(1); }
}

/* REVEAL: new emblem emerges + rift edge flicker */
.rankup[data-phase="reveal"] .rankup__emblem--new{
  animation: ruNewReveal 1.05s cubic-bezier(.12,.95,.18,1) forwards;
}
.rankup[data-phase="reveal"] .rankup__riftEdge{
  animation: ruEdgeFlicker 1s ease .15s forwards;
}
@keyframes ruNewReveal{
  0%{
    opacity:0;
    transform: translateY(90px) scale(.55);
    filter: blur(1px) drop-shadow(0 0 30px rgba(168,85,255,.35));
  }
  45%{
    opacity:1;
    transform: translateY(-10px) scale(1.06);
    filter: blur(0) drop-shadow(0 0 40px rgba(35,243,255,.28));
  }
  100%{
    opacity:1;
    transform: translateY(0) scale(1);
    filter: blur(0) drop-shadow(0 0 22px rgba(35,243,255,.26));
  }
  .rankup[data-phase="reveal"] .rankup__beams{
  opacity: .55;
  transform: scale(1.03) rotate(14deg);
  }
}
@keyframes ruEdgeFlicker{
  0%{ opacity:.55; }
  30%{ opacity:.15; transform: translateX(2px); }
  60%{ opacity:.45; transform: translateX(-2px); }
  100%{ opacity:.28; transform: translateX(0); }
}

/* DONE: CTA in */
.rankup[data-phase="done"] .rankup__cta{
  animation: ruCtaIn .55s cubic-bezier(.2,.9,.2,1) forwards;
}
  /* DONE: keep NEW emblem visible + keep OLD hidden */
.rankup[data-phase="done"] .rankup__emblem--new{
  opacity: 1;
  transform: translateY(0) scale(1);
  filter: blur(0) drop-shadow(0 0 22px rgba(35,243,255,.26));
}

.rankup[data-phase="done"] .rankup__emblem--old{
  opacity: 0;
}
@keyframes ruCtaIn{ to{ opacity:1; transform: translateY(0); } }

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  .rankup__scan,.rankup__rift::after,.rankup__badge::after{ animation:none!important; }
  .rankup[data-phase="open"] .rankup__rift,
  .rankup[data-phase="open"] .rankup__riftEdge,
  .rankup[data-phase="collapse"] .rankup__emblem--old,
  .rankup[data-phase="impact"] .rankup__stage,
  .rankup[data-phase="impact"] .rankup__burst,
  .rankup[data-phase="reveal"] .rankup__emblem--new,
  .rankup[data-phase="reveal"] .rankup__riftEdge,
  .rankup[data-phase="done"] .rankup__cta{
    animation:none!important;
    .rankup__beams, .rankup__chroma, .rankup__shards{ display:none!important; }
.rankup__stage{ filter:none!important; }
  }
  .rankup{ transition:none!important; }
  .rankup.is-open{ opacity:1; }
  .rankup__stage{ opacity:1; transform:none; }
  .rankup__rift{ opacity:1; transform:none; }
  .rankup__emblem--old{ opacity:0; }
  .rankup__emblem--new{ opacity:1; transform:none; filter:none; }
  .rankup__cta{ opacity:1; transform:none; }
}
  .rankup__img{
  width: 100%;
  height: 100%;
  object-fit: contain;
  display:block;
  pointer-events:none;
  filter: drop-shadow(0 0 18px rgba(35,243,255,.25));
}
.rankup__badge{
  display:grid;
  place-items:center;
}
.rankup__badge .rankup__img{
  width: 120px;
  height: 120px;
}
  
  /* Tier mode: no rift, no collapse */
.rankup[data-type="tier"] .rankup__riftWrap{ display:none; }
.rankup[data-type="tier"] .rankup__emblem--old{ display:none; }
.rankup[data-type="tier"] .rankup__hudRight{ opacity:.85; }
  /* Tier mode: make stage smaller + snappier */
.rankup[data-type="tier"] .rankup__stage{
  height: min(380px, 62vh);
}
.rankup[data-type="tier"] .rankup__cta{ display:none; }

  /* Top rank: keep rift alive in DONE (afterglow stays) */
.rankup[data-top="1"][data-phase="done"] .rankup__rift{
  opacity: 1;
}
.rankup[data-top="1"][data-phase="done"] .rankup__riftEdge{
  opacity: .55;
}
.rankup[data-top="1"][data-phase="done"] .rankup__burst{
  opacity: .18;
  transform: scale(1.05);
}
  .rankup[data-phase="done"] .rankup__badge--new{
  animation: ruAfterglowBreath 2.2s ease-in-out infinite;
}

@keyframes ruAfterglowBreath{
  0%,100%{ box-shadow: 0 0 18px rgba(168,85,255,.35), 0 0 42px rgba(35,243,255,.18); }
  50%{ box-shadow: 0 0 26px rgba(168,85,255,.45), 0 0 70px rgba(35,243,255,.26); }
}
  /* TEMP FIX: hide legacy cinematic overlay */
#cinematic { display: none !important; }
.cinematic { display: none !important; }
  
</style>
  <!-- ===== END OF CSS ===== -->
</head>
  
<!-- ============================= -->
<!-- ===== APPLICATION UI ======= -->
<!-- ============================= -->
<body>

<!-- NAVIGATION -->
<div class="navbar">
  <button class="nav-btn active" onclick="showTab('dashboard', this)">DASHBOARD</button>
  <button class="nav-btn" onclick="showTab('rank', this)">RANK</button>
  <button class="nav-btn" onclick="showTab('history', this)">MATCH HISTORY</button>
  <button class="nav-btn" onclick="showTab('add', this)">ADD MATCH</button>
</div>

<!-- DASHBOARD -->
<div id="dashboard" class="section active">
  <h1>Player Dashboard</h1>
  <p>Overview of your ranked progress.</p>

  <div class="panel">
    <p>üîπ Current RP: <strong>1250</strong></p>
    <p>üîπ Current Rank: <strong>PHANTOM II</strong></p>
    <p>üîπ Win Streak: <strong>3</strong></p>
  </div>
  <div class="actions" style="margin-top:14px;">
  <button class="btn ghost" type="button" onclick="startNewSeason()">Start New Season</button>
  <div class="hint">Starts a new season (RR resets). Past seasons remain available.</div>
</div>
</div>

<!-- RANK -->
<div id="rank" class="section">
  <h1>Competitive Rank</h1>
  <p>Your current competitive standing.</p>

  <!-- RANK CARD -->
  <div class="rank-card">
    <div class="rank-bg"></div>
    <div class="rank-noise"></div>

    <div class="rank-icon" id="rankCardIcon">
  <img id="rankBadgeImg" src="" alt="Rank badge">
  <div class="rank-glow"></div>
    </div>

    <div class="rank-info">
      <h2 id="rankCardTitle">PHANTOM II</h2>
      <span class="rank-rp" id="rankCardRP">RP: 1250 / 1500</span>
      <div class="chip" id="rankCardChip">NEON ASCENSION</div>

      <div class="rp-bar">
        <div class="rp-fill" id="rankCardFill" style="width: 83%;"></div>
      </div>
    </div>
  </div>

  <!-- RANK LADDER (OUTSIDE rank-card) -->
  <div class="ladder">
    <div class="ladder-head">
      <h3>Rank Ladder</h3>
      <span class="ladder-note">Locked ranks are dimmed. Current rank is highlighted.</span>
    </div>

    <div class="ladder-list">
      <div class="ladder-item unlocked">
        <div class="badge b-outcast"></div>
        <div class="meta">
          <div class="name">OUTCAST</div>
          <div class="desc">Chaos-born survivors.</div>
        </div>
      </div>

      <div class="ladder-item unlocked">
        <div class="badge b-vanguard"></div>
        <div class="meta">
          <div class="name">VANGUARD</div>
          <div class="desc">Rising force.</div>
        </div>
      </div>

      <div class="ladder-item unlocked">
        <div class="badge b-sentinel"></div>
        <div class="meta">
          <div class="name">SENTINEL</div>
          <div class="desc">Control & discipline.</div>
        </div>
      </div>

      <div class="ladder-item unlocked current">
        <div class="badge b-phantom"></div>
        <div class="meta">
          <div class="name">PHANTOM</div>
          <div class="desc">Precision mastery.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-warlord"></div>
        <div class="meta">
          <div class="name">WARLORD</div>
          <div class="desc">Aggressive dominance.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-archon"></div>
        <div class="meta">
          <div class="name">ARCHON</div>
          <div class="desc">Authority.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-overseer"></div>
        <div class="meta">
          <div class="name">OVERSEER</div>
          <div class="desc">Vision & tactics.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-ascendant"></div>
        <div class="meta">
          <div class="name">ASCENDANT</div>
          <div class="desc">Transcendence.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-paragon"></div>
        <div class="meta">
          <div class="name">PARAGON</div>
          <div class="desc">Elite standard.</div>
        </div>
      </div>

      <div class="ladder-item locked nexus">
        <div class="badge b-nexus"></div>
        <div class="meta">
          <div class="name">NEXUS</div>
          <div class="desc">Absolute peak.</div>
        </div>
      </div>
    </div>
  </div>
</div>

  
<!-- ADD MATCH -->
<div id="add" class="section">
  <h1>Add Match</h1>
  <p>Enter your match results. Everything updates automatically.</p>

  <div class="panel form">
    <div class="grid">
      <label>üèÜ Place (1‚Äì25)
        <input id="inPlace" type="number" min="1" max="25" value="10">
      </label>

      <label>üî´ Kills
        <input id="inKills" type="number" min="0" value="0">
      </label>

      <label>ü§ù Assists
        <input id="inAssists" type="number" min="0" value="0">
      </label>

      <label>üíÄ Deaths
        <input id="inDeaths" type="number" min="0" value="1">
      </label>
    </div>

    <div class="toggles">
      <label class="toggle">
        <input id="inMVP" type="checkbox">
        <span>‚≠ê MVP</span>
      </label>

      <label class="toggle">
        <input id="inLeft" type="checkbox">
        <span>‚ö† Teammate Left</span>
      </label>
    </div>

    <div class="actions">
      <button type="button" class="btn" onclick="submitMatch()">Submit Match</button>
      <button class="btn" onclick="undoLastMatch()">Undo Last Match</button>
      <button class="btn ghost" onclick="resetMatches()">Reset All Data</button>
      <div class="hint">Data is stored locally in your browser.</div>
    </div>
    <div class="panel" style="margin-top:16px;">
  <h3 style="margin-bottom:10px; letter-spacing:.6px;">Export / Import</h3>
  <p style="color:#9ca3af; font-size:12px; margin-bottom:10px;">
    Backup your matches as JSON, or import them on another device.
  </p>

  <textarea id="ioBox" rows="8" style="
    width:100%;
    resize:vertical;
    padding:12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.08);
    background:rgba(2,6,23,0.55);
    color:#e5e7eb;
    outline:none;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    font-size:12px;
    line-height:1.4;
  " placeholder="Paste JSON here (Import) or click Export to generate..."></textarea>

  <div class="actions" style="margin-top:10px;">
    <button class="btn" onclick="exportData()">Export JSON</button>
    <button class="btn" onclick="importData()">Import JSON</button>
    <button class="btn ghost" onclick="clearIO()">Clear Box</button>
    <button class="btn ghost" onclick="restoreBackup()">Restore Backup</button>
  </div>

  <div class="hint">Tip: Export copies JSON to clipboard automatically.</div>
</div>
  </div>
</div>

<!-- HISTORY -->
<div id="history" class="section">
  <h1>Match History</h1>
  <p>Your recent ranked matches and RP changes.</p>

  <div class="history-top">
    <div class="mini-card">
      <div class="mini-label">Win Streak</div>
      <div class="mini-value" id="streakValue">0</div>
    </div>
    <div class="mini-card">
      <div class="mini-label">Best Match</div>
      <div class="mini-value" id="bestValue">+0</div>
    </div>
    <div class="mini-card">
      <div class="mini-label">Worst Match</div>
      <div class="mini-value" id="worstValue">0</div>
    </div>
    <div class="season-summary" id="seasonSummary"></div>
  </div>

  <div class="history-controls">
  <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
    <label style="font-size:12px; color:#9ca3af;">Season:</label>
    <select id="seasonSelect" class="season-select"></select>
    <span id="readOnlyBadge" class="ro-badge" style="display:none;">READ ONLY</span>
    <button class="btn" id="toggleHistoryBtn" type="button">Show all</button>
    <button class="btn" type="button" onclick="renameSeason()">Rename</button>
    <button class="btn" type="button" onclick="renumberSeasonIds()">Fix IDs</button>
    <button class="btn ghost" type="button" onclick="deleteSeason()">Delete</button>
  </div>
  <div class="hint" id="historyHint">Showing last 20 matches</div>
</div>

<div class="match-list" id="matchList"></div>
</div>

<!-- ============================= -->
<!-- ===== CINEMATIC OVERLAY ===== -->
<!-- ============================= -->


        <div class="cin-rankText" id="cinRankText">OUTCAST II</div>
        <div class="cin-hint">Press <span class="cin-key">Esc</span> to close</div>
      </div>
    </div>
  </div>
</div>
  
<!-- ============================= -->
<!-- ===== APPLICATION LOGIC ===== -->
<!-- ===== JAVASCRIPT (JS) ======= -->
<!-- ============================= -->
<script>
  var sfxUp = null;
var sfxDown = null;

function preloadSfx() {
  // If files missing, it won't crash; just won't play.
  try {
    sfxUp = new Audio("assets/sfx/rank_up.mp3");
    sfxUp.preload = "auto";
    sfxUp.volume = 0.7;
  } catch(e) {}

  try {
    sfxDown = new Audio("assets/sfx/rank_down.mp3");
    sfxDown.preload = "auto";
    sfxDown.volume = 0.7;
  } catch(e) {}
}

function playSfx(mode) {
  // mode: "up" | "down"
  try {
    var a = (mode === "down") ? sfxDown : sfxUp;
    if (!a) return;
    a.currentTime = 0;
    a.play();
  } catch(e) {}
}
  
  function preloadRankBadges() {
  for (var i = 0; i < rankTiers.length; i++) {
    var img = new Image();
    img.src = "assets/ranks/" + String(rankTiers[i].name).toLowerCase() + ".webp";
  }
}
  
/* ===== NAV ===== */
function showTab(tabId, btn) {
  var sections = document.querySelectorAll(".section");
  for (var i = 0; i < sections.length; i++) sections[i].classList.remove("active");

  var buttons = document.querySelectorAll(".nav-btn");
  for (var j = 0; j < buttons.length; j++) buttons[j].classList.remove("active");

  var target = document.getElementById(tabId);
  if (target) target.classList.add("active");
  // Lock RP: when going to ADD MATCH, always switch viewing to ACTIVE season
  if (tabId === "add") {
    ensureSeasonSystem();
    var activeId = getActiveSeasonId();
    if (activeId) setSelectedSeasonId(activeId);
  }
  if (btn) btn.classList.add("active");
}

/* ===== STORAGE ===== */
var STORAGE_KEY = "bf6_ranked_matches_v1";
  var BACKUP_KEY = "bf6_backup_v1";

function makeBackup(reason) {
  var payload = {
    version: 1,
    reason: reason || "manual",
    createdAt: Date.now(),
    seasons: loadSeasons(),
    activeSeasonId: getActiveSeasonId(),
    selectedSeasonId: getSelectedSeasonId(),
    matches: loadMatches()
  };
  localStorage.setItem(BACKUP_KEY, JSON.stringify(payload));
}

function restoreBackup() {
  var raw = localStorage.getItem(BACKUP_KEY);
  if (!raw) {
    alert("No backup found.");
    return;
  }

  var payload;
  try {
    payload = JSON.parse(raw);
  } catch (e) {
    alert("Backup is corrupted.");
    return;
  }

  if (!payload || !Array.isArray(payload.matches) || !Array.isArray(payload.seasons)) {
    alert("Backup format invalid.");
    return;
  }

  if (!confirm("Restore backup? This will replace current data.")) return;

  saveMatches(payload.matches);
  saveSeasons(payload.seasons);

  setActiveSeasonId(payload.activeSeasonId || (payload.seasons[0] && payload.seasons[0].id) || "S1");
  setSelectedSeasonId(payload.selectedSeasonId || getActiveSeasonId());

  lastRankState = null;
  renderHistoryFromStorage();

  alert("Backup restored.");
}
var SEASONS_KEY = "bf6_seasons_v1";
var ACTIVE_SEASON_KEY = "bf6_active_season_v1";
var SELECTED_SEASON_KEY = "bf6_selected_season_v1"; // for UI viewing

function loadSeasons() {
  try {
    var raw = localStorage.getItem(SEASONS_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    return [];
  }
}

function saveSeasons(seasons) {
  localStorage.setItem(SEASONS_KEY, JSON.stringify(seasons));
}

function getActiveSeasonId() {
  return localStorage.getItem(ACTIVE_SEASON_KEY);
}

function setActiveSeasonId(id) {
  localStorage.setItem(ACTIVE_SEASON_KEY, id);
}

function getSelectedSeasonId() {
  // Selected season for viewing; default to active
  var v = localStorage.getItem(SELECTED_SEASON_KEY);
  return v ? v : getActiveSeasonId();
}

function setSelectedSeasonId(id) {
  localStorage.setItem(SELECTED_SEASON_KEY, id);
}

function ensureSeasonSystem() {
  var seasons = loadSeasons();
  // Backfill season name for legacy seasons
  var changed = false;
  for (var i = 0; i < seasons.length; i++) {
    if (!seasons[i].name) {
      seasons[i].name = seasons[i].id; // default name
      changed = true;
    }
  }
  if (changed) saveSeasons(seasons);
  var active = getActiveSeasonId();

  if (!seasons || seasons.length === 0 || !active) {
    // Create first season
    var id = "S1";
    var season = {
      id: id,
      startAt: Date.now(),
      endAt: null,
      finalRR: null,
      finalRankLabel: null,
      stats: null
    };
    saveSeasons([season]);
    setActiveSeasonId(id);
    setSelectedSeasonId(id);
    return;
  }

  // If selected missing, set to active
  var selected = getSelectedSeasonId();
  if (!selected) setSelectedSeasonId(active);
}
  function computeSeasonStats(matches) {
  var count = matches.length;
  if (count === 0) {
    return {
      matchesCount: 0,
      bestRR: 0,
      worstRR: 0,
      avgRR: 0,
      top1Count: 0,
      top3Count: 0,
      top7Count: 0,
      mvpCount: 0,
      leftCount: 0
    };
  }

  var best = -Infinity;
  var worst = Infinity;
  var sum = 0;

  var top1 = 0, top3 = 0, top7 = 0, mvpCount = 0, leftCount = 0;

  for (var i = 0; i < matches.length; i++) {
    var m = matches[i];
    var rr = Number(m.rp || 0);
    sum += rr;
    if (rr > best) best = rr;
    if (rr < worst) worst = rr;

    var p = Number(m.place || 99);
    if (p === 1) top1++;
    if (p <= 3) top3++;
    if (p <= 7) top7++;

    if (m.mvp) mvpCount++;
    if (m.left) leftCount++;
  }

  return {
    matchesCount: count,
    bestRR: best,
    worstRR: worst,
    avgRR: Math.round(sum / count),
    top1Count: top1,
    top3Count: top3,
    top7Count: top7,
    mvpCount: mvpCount,
    leftCount: leftCount
  };
}
  
var HISTORY_LIMIT_KEY = "bf6_history_limit_v1";

function loadMatches() {
  try {
    var raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    return [];
  }
}

function saveMatches(matches) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
}
  
  
/* ===== RANK SETTINGS (Valorant-like divisions) ===== */
var START_RP = 0;
var MIN_RP = 0;
var DIV_RR = 100;
var DIVS_PER_TIER = 3;

/*
IMPORTANT:
To have exactly 3 divisions per tier (III/II/I), each tier should span 300 RR.
So tier mins are spaced by 300.
This also makes ranking progression consistent and hard.
*/
var rankTiers = [
  { name: "OUTCAST",  color: "#ffb86b", min: 0   },
  { name: "VANGUARD", color: "#22d3ee", min: 300 },
  { name: "SENTINEL", color: "#38bdf8", min: 600 },
  { name: "PHANTOM",  color: "#a78bfa", min: 900 },
  { name: "WARLORD",  color: "#fb7185", min: 1200 },
  { name: "ARCHON",   color: "#fbbf24", min: 1500 },
  { name: "OVERSEER", color: "#2dd4bf", min: 1800 },
  { name: "ASCENDANT",color: "#60a5fa", min: 2100 },
  { name: "PARAGON",  color: "#e5e7eb", min: 2400 },
  { name: "NEXUS",    color: "#ff3b3b", min: 2700 }
];

// cinematic tracking (tier + division)
var lastRankState = null; // { tierIndex, divIndex, label }

/* ===== RANK CALC ===== */
function getRank(totalRP) {
  // find tier index
  var tierIndex = 0;
  for (var i = 0; i < rankTiers.length; i++) {
    if (totalRP >= rankTiers[i].min) tierIndex = i;
  }

  var tier = rankTiers[tierIndex];

  // NEXUS special case
  if (tier.name === "NEXUS") {
    return {
      label: "NEXUS",
      tierName: "NEXUS",
      tierIndex: tierIndex,
      div: null,
      divIndex: null,
      color: tier.color,
      rr: 100,
      nextMin: null
    };
  }

  var nextTier = rankTiers[tierIndex + 1];

  // RR inside this tier
  var rrInTier = totalRP - tier.min;
  if (rrInTier < 0) rrInTier = 0;

  // Division index (0..2) based on 100 RR chunks
  var divIndex = Math.floor(rrInTier / DIV_RR);
  if (divIndex < 0) divIndex = 0;
  if (divIndex > (DIVS_PER_TIER - 1)) divIndex = (DIVS_PER_TIER - 1);

  // RR progress inside current division (0..99)
  var rr = rrInTier - (divIndex * DIV_RR);
  if (rr < 0) rr = 0;
  if (rr > (DIV_RR - 1)) rr = (DIV_RR - 1);

  // Division label mapping: 0->III, 1->II, 2->I
  var div = (divIndex === 0) ? "III" : (divIndex === 1 ? "II" : "I");

  // Label
  var label = tier.name + " " + div;

  // Next threshold shown on UI
  var nextMin = null;
  if (divIndex === (DIVS_PER_TIER - 1)) nextMin = nextTier ? nextTier.min : null;
  else nextMin = tier.min + ((divIndex + 1) * DIV_RR);

  return {
    label: label,
    tierName: tier.name,
    tierIndex: tierIndex,
    div: div,
    divIndex: divIndex,
    color: tier.color,
    rr: rr, // 0..99
    nextMin: nextMin
  };
}

/* ===== BR RR FORMULA (hard to climb) ===== */
function calcRPBreakdown(m) {
  var place = Math.min(25, Math.max(1, Number(m.place || 25)));
  var kills = Math.max(0, Number(m.kills || 0));
  var assists = Math.max(0, Number(m.assists || 0));
  var deaths = Math.max(0, Number(m.deaths || 0));
  var mvp = !!m.mvp;
  var left = !!m.left;

  var contrib = kills + assists;

  // Contribution tiers
  var isLow = contrib < 5;
  var isNormal = contrib >= 5;
  var isHigh = (kills >= 10) || (contrib >= 20);

  // Placement base
  var placementBase = 0;
  if (place === 1) placementBase = 26;
  else if (place === 2) placementBase = 22;
  else if (place === 3) placementBase = 20;
  else if (place === 4) placementBase = 17;
  else if (place === 5) placementBase = 15;
  else if (place === 6) placementBase = 13;
  else if (place === 7) placementBase = 11;
  else if (place >= 8 && place <= 11) placementBase = 0;
  else if (place >= 12 && place <= 15) placementBase = -2;
  else if (place === 16) placementBase = -4;
  else if (place === 17) placementBase = -6;
  else if (place === 18) placementBase = -8;
  else if (place === 19) placementBase = -10;
  else if (place === 20) placementBase = -12;
  else if (place === 21) placementBase = -14;
  else if (place === 22) placementBase = -16;
  else if (place === 23) placementBase = -18;
  else if (place === 24) placementBase = -20;
  else placementBase = -22;

  // Placement modifier by contribution
  var placementMod = 0;
  if (place <= 7) {
    if (isHigh) placementMod = 2;
    else if (isNormal) placementMod = 1;
    else placementMod = 0;
  } else if (place >= 8 && place <= 11) {
    if (isHigh) placementMod = 3;
    else if (isNormal) placementMod = 2;
    else placementMod = 0;
  } else if (place >= 12 && place <= 15) {
    if (isHigh) placementMod = 3;        // -2 +3 = +1
    else if (isNormal) placementMod = 2;  // -2 +2 = 0
    else placementMod = -2;              // -2 -2 = -4
  } else {
    placementMod = 0; // place > 15: no mod
  }

  var placementScore = placementBase + placementMod;

  // Combat score (normalized & capped)
  var killScore = 0;
  var k1 = Math.min(kills, 5);
  var k2 = Math.min(Math.max(kills - 5, 0), 5);
  killScore += k1 * 2;
  killScore += k2 * 1;

  var assistScore = 0;
  var a1 = Math.min(assists, 5);
  var a2 = Math.min(Math.max(assists - 5, 0), 5);
  assistScore += a1 * 1;
  assistScore += a2 * 0.5;

  var deathScore = -2 * deaths;
  if (deathScore < -10) deathScore = -10;

  var combatScore = killScore + assistScore + deathScore;
  if (combatScore > 14) combatScore = 14;

  var mvpBonus = mvp ? 3 : 0;

  var leftBonus = 0;
  if (left) {
    if (place === 1) leftBonus = 10;
    else if (place <= 3) leftBonus = 7;
    else if (place <= 7) leftBonus = 4;
  }

  var total = placementScore + combatScore + mvpBonus + leftBonus;

  // Clamp final RR per match
  if (total > 32) total = 32;
  if (total < -25) total = -25;

  // Invalid-ish protection
  if (left && place > 15 && total < -8) total = -8;

  total = Math.round(total);

  return {
    place: place,
    contrib: contrib,
    placementBase: placementBase,
    placementMod: placementMod,
    placementScore: placementScore,
    killScore: killScore,
    assistScore: assistScore,
    deathScore: deathScore,
    combatScore: combatScore,
    mvpBonus: mvpBonus,
    leftBonus: leftBonus,
    total: total
  };
}

/* ===== CINEMATIC (V3) ===== */
function getTierNameFromLabel(label) {
  return String(label || "").trim().split(" ")[0].toUpperCase();
}

function getTierKeyFromLabel(label) {
  return getTierNameFromLabel(label).toLowerCase();
}

function closeCinematic() {
  var el = document.getElementById("cinematic");
  if (!el) return;
  el.classList.remove("is-open");
  el.setAttribute("aria-hidden", "true");
}

function showCinematic(fromRank, toRank, isPromotion, changeType) {
  // changeType: "division" | "tier"
  var el = document.getElementById("cinematic");
  var title = document.getElementById("cinTitle");
  var sub = document.getElementById("cinSub");
  var badge = document.getElementById("cinBadgeImg");
  var rankText = document.getElementById("cinRankText");

  var card = document.querySelector("#cinematic .cin-card");
  var burst = document.querySelector("#cinematic .cin-burst");
  var rays = document.querySelector("#cinematic .cin-rays");
  var flash = document.querySelector("#cinematic .cin-flash");
  var shock = document.querySelector("#cinematic .cin-shockwave");
  var glowf = document.querySelector("#cinematic .cin-glowfield");
  var ring = document.querySelector("#cinematic .cin-badgeRing");

  if (!el || !title || !sub || !card) return;

  var mode = isPromotion ? "up" : "down";
  el.dataset.mode = mode;

  // Accent from tier color
  var toTier = getTierNameFromLabel(toRank);
  var accent = "#22d3ee";
  for (var i = 0; i < rankTiers.length; i++) {
    if (rankTiers[i].name === toTier) accent = rankTiers[i].color;
  }
  el.style.setProperty("--cin-accent", accent);

  // Text
  if (changeType === "tier") title.textContent = isPromotion ? "TIER UP" : "TIER DOWN";
  else title.textContent = isPromotion ? "DIVISION UP" : "DIVISION DOWN";

  sub.textContent = String(fromRank) + " ‚Üí " + String(toRank);
  if (rankText) rankText.textContent = String(toRank);

  // Badge image
  if (badge) badge.src = "assets/ranks/" + getTierKeyFromLabel(toRank) + ".webp";

  // Open overlay
  if (window.__cinT) clearTimeout(window.__cinT);
  el.classList.add("is-open");
  el.setAttribute("aria-hidden", "false");

  // Timings (tier is longer + more epic)
  var durCard = (changeType === "tier") ? 780 : 520;
  var durFx = (changeType === "tier") ? 980 : 720;
  var closeAfter = (changeType === "tier") ? 2800 : 1700;

  // Easing presets
  var easeInOut = "cubic-bezier(.2,.9,.2,1)";
  var easeOut = "cubic-bezier(.12,.92,.18,1)";

  // -----------------
  // CARD TIMELINE
  // -----------------
  // Promotion: stronger "lift + impact"
  // Demotion: slight "drop + heavier settle"
  var cardStartY = isPromotion ? 30 : -14;
  var cardMidY = isPromotion ? 6 : 10;
  var cardImpactY = isPromotion ? -4 : 4;
  var cardScaleStart = isPromotion ? 0.94 : 0.98;

  card.animate([
    { opacity: 0, transform: "translate3d(0," + cardStartY + "px,0) scale(" + cardScaleStart + ")" },
    { opacity: 1, transform: "translate3d(0," + cardMidY + "px,0) scale(0.985)", offset: 0.34 },
    { opacity: 1, transform: "translate3d(0," + cardImpactY + "px,0) scale(1.03)", offset: 0.62 },
    { opacity: 1, transform: "translate3d(0,0,0) scale(1)" }
  ], { duration: durCard, easing: easeInOut, fill: "forwards" });

  // Tier-up: micro shake for impact (transform only, no lag)
  if (changeType === "tier" && isPromotion) {
    card.animate([
      { transform: "translate3d(0,0,0)" },
      { transform: "translate3d(-7px,0,0)", offset: 0.12 },
      { transform: "translate3d(7px,0,0)", offset: 0.24 },
      { transform: "translate3d(-4px,0,0)", offset: 0.36 },
      { transform: "translate3d(0,0,0)" }
    ], { duration: 420, easing: "ease-out", fill: "none", delay: 260 });
  }

  // -----------------
  // BADGE POP
  // -----------------
  if (badge) {
    badge.animate([
      { opacity: 0, transform: "translate3d(0,16px,0) scale(0.84)" },
      { opacity: 1, transform: "translate3d(0,2px,0) scale(0.98)", offset: 0.34 },
      { opacity: 1, transform: "translate3d(0,-2px,0) scale(1.10)", offset: 0.62 },
      { opacity: 1, transform: "translate3d(0,0,0) scale(1)" }
    ], { duration: durCard, delay: 120, easing: easeOut, fill: "forwards" });
  }

  // Ring subtle spin (cheap)
  if (ring) {
    ring.animate([
      { opacity: 0.85, transform: "rotate(0deg)" },
      { opacity: 1.0, transform: "rotate(120deg)" },
      { opacity: 0.9, transform: "rotate(220deg)" }
    ], { duration: durFx, easing: "linear", fill: "forwards" });
  }

  // -----------------
  // FX: Burst / Rays / Flash
  // -----------------
  if (burst) {
    burst.animate([
      { opacity: 0, transform: "scale(0.90)" },
      { opacity: (isPromotion ? 0.9 : 0.55), transform: "scale(1.05)", offset: 0.42 },
      { opacity: 0.22, transform: "scale(1.00)" }
    ], { duration: durFx, easing: "ease-out", fill: "forwards" });
  }

  if (rays) {
    rays.animate([
      { opacity: 0, transform: "scale(0.96) rotate(0deg)" },
      { opacity: (isPromotion ? 0.65 : 0.35), transform: "scale(1.03) rotate(12deg)", offset: 0.45 },
      { opacity: 0.14, transform: "scale(1.00) rotate(18deg)" }
    ], { duration: durFx, easing: "ease-out", fill: "forwards" });
  }

  // Flash is only for tier changes (big moment)
  if (flash) {
    var flashPeak = (changeType === "tier") ? (isPromotion ? 0.55 : 0.28) : 0.0;
    flash.animate([
      { opacity: 0 },
      { opacity: flashPeak, offset: 0.35 },
      { opacity: 0.0 }
    ], { duration: (changeType === "tier" ? 680 : 1), easing: "ease-out", fill: "forwards", delay: 110 });
  }
// -----------------
// EPIC MOMENT (Tier only)
// -----------------
if (changeType === "tier") {
  // Glowfield "charge"
  if (glowf) {
    glowf.animate([
      { opacity: 0, transform: "scale(0.95)" },
      { opacity: 0.55, transform: "scale(1.03)", offset: 0.45 },
      { opacity: 0.18, transform: "scale(1.00)" }
    ], { duration: 1100, easing: "ease-out", fill: "forwards" });
  }

  // Shockwave "impact"
  if (shock) {
    shock.animate([
      { opacity: 0, transform: "scale(0.25)" },
      { opacity: 0.55, transform: "scale(0.55)", offset: 0.25 },
      { opacity: 0.22, transform: "scale(1.10)", offset: 0.65 },
      { opacity: 0.0, transform: "scale(1.35)" }
    ], { duration: 900, easing: "cubic-bezier(.1,.9,.2,1)", fill: "forwards", delay: 120 });
  }

  // Extra badge "power punch" (small, no lag)
  if (badge) {
    badge.animate([
      { transform: "scale(1)" },
      { transform: "scale(1.14)", offset: 0.35 },
      { transform: "scale(1.00)" }
    ], { duration: 520, easing: "cubic-bezier(.2,.9,.2,1)", fill: "forwards", delay: 340 });
  }
}
  // Auto-close
  window.__cinT = setTimeout(function () {
    el.classList.remove("is-open");
    el.setAttribute("aria-hidden", "true");
  }, closeAfter);
}

// Close UX: Esc + click on backdrop
document.addEventListener("keydown", function(e){
  if (e.key === "Escape") closeCinematic();
});

document.addEventListener("click", function(e){
  var el = document.getElementById("cinematic");
  if (!el || !el.classList.contains("is-open")) return;

  // Close only if clicking background/root (not the card)
  var t = e.target;
  var bg = t && t.classList && t.classList.contains("cinematic-bg");
  var root = t === el;
  if (bg || root) closeCinematic();
});

/* ===== LADDER UI ===== */
function updateLadderUI(currentTierIndex) {
  var items = document.querySelectorAll(".ladder-list .ladder-item");

  for (var i = 0; i < items.length; i++) {
    var item = items[i];

    // State classes
    item.classList.remove("locked", "unlocked", "current");
    if (i < currentTierIndex) item.classList.add("unlocked");
    else if (i === currentTierIndex) item.classList.add("unlocked", "current");
    else item.classList.add("locked");

    // Badge image from rankTiers (reliable)
    var badgeEl = item.querySelector(".badge");
    if (badgeEl && rankTiers[i] && rankTiers[i].name) {
      var tierKey = String(rankTiers[i].name).toLowerCase();

      // Force override ANY existing gradient backgrounds
      badgeEl.style.background = 'url("assets/ranks/' + tierKey + '.webp") center / contain no-repeat';
    }
  }
}

/* ===== UI UPDATES ===== */
function updateRankUI(matchesAll) {
  // Backfill breakdown for old matches
  for (var bi = 0; bi < matchesAll.length; bi++) {
    if (!matchesAll[bi].breakdown) {
      matchesAll[bi].breakdown = calcRPBreakdown(matchesAll[bi]);
      matchesAll[bi].rp = matchesAll[bi].breakdown.total;
    }
  }

  var sum = 0;
  for (var i = 0; i < matchesAll.length; i++) sum += Number(matchesAll[i].rp || 0);

  var totalRP = START_RP + sum;
  if (totalRP < MIN_RP) totalRP = MIN_RP;

  var rank = getRank(totalRP);

  // Rank card elements (IDs preferred)
  var rankTitle = document.getElementById("rankCardTitle") || document.querySelector("#rank .rank-info h2");
  var rankRP = document.getElementById("rankCardRP") || document.querySelector("#rank .rank-rp");
  var rpFill = document.getElementById("rankCardFill") || document.querySelector("#rank .rp-fill");
  var chip = document.getElementById("rankCardChip");
  var icon = document.getElementById("rankCardIcon");

  if (rankTitle) rankTitle.textContent = rank.label;
  // Rank badge image
const badgeImg = document.getElementById("rankBadgeImg");
if (badgeImg && rank.tierName) {
  const tierKey = rank.tierName.toLowerCase();
  badgeImg.src = "assets/ranks/" + tierKey + ".webp";
}

  if (rankRP) {
    if (rank.tierName === "NEXUS") rankRP.textContent = "RR: " + totalRP + " (MAX)";
    else rankRP.textContent = "RR: " + totalRP + " / " + rank.nextMin;
  }

  if (rpFill) {
    var pct = Math.round((rank.rr / (DIV_RR - 1)) * 100);
    rpFill.style.width = String(pct) + "%";
  }

  if (chip) {
    chip.textContent = rank.tierName === "NEXUS" ? "ABSOLUTE PEAK" : ("TIER: " + rank.tierName);
  }
  if (icon) {
    icon.style.setProperty("--rank-accent", rank.color);
  }

  updateLadderUI(rank.tierIndex);

  // Dashboard
  var dash = document.querySelector("#dashboard .panel");
  if (dash) {
    dash.innerHTML =
      "<p>üîπ Current RR: <strong>" + totalRP + "</strong></p>" +
      "<p>üîπ Current Rank: <strong>" + rank.label + "</strong></p>" +
      "<p>üîπ Matches: <strong>" + matchesAll.length + "</strong></p>";
  }

  // Cinematic trigger (tier + division)
var currentState = { tierIndex: rank.tierIndex, divIndex: rank.divIndex, label: rank.label };

if (lastRankState === null) {
  lastRankState = currentState;
} else {
  var tierChanged = currentState.tierIndex !== lastRankState.tierIndex;
  var divChanged = currentState.divIndex !== lastRankState.divIndex;

  if (tierChanged) {
    var promotedTier = currentState.tierIndex > lastRankState.tierIndex;

    if (typeof window.showRankUp === "function") {
      window.showRankUp({
        fromText: lastRankState.label,
        toText: currentState.label,
        rrText: promotedTier ? "NEW RANK UNLOCKED" : "RANK DOWN"
      });
    }

    lastRankState = currentState;
  } else if (divChanged) {
    var a = (currentState.divIndex === null || currentState.divIndex === undefined) ? 0 : currentState.divIndex;
    var b = (lastRankState.divIndex === null || lastRankState.divIndex === undefined) ? 0 : lastRankState.divIndex;
    var promotedDiv = a > b;

    if (typeof window.showTierUp === "function") {
      window.showTierUp({
        fromText: lastRankState.label,
        toText: currentState.label,
        rrText: promotedDiv ? "TIER UPGRADED" : "TIER DOWNGRADED"
      });
    }

    lastRankState = currentState;
    }
  }
}

function getHistoryLimit() {
  // "20" or "all"
  var v = localStorage.getItem(HISTORY_LIMIT_KEY);
  return v ? v : "20";
}

function setHistoryLimit(val) {
  localStorage.setItem(HISTORY_LIMIT_KEY, val);
}
  
function renderHistoryFromStorage() {
  var matchesAll = loadMatches();
  // Backfill matchId for legacy matches
var changedId = false;
for (var mi = 0; mi < matchesAll.length; mi++) {
  if (!matchesAll[mi].matchId) {
    matchesAll[mi].matchId = genMatchId(matchesAll[mi].ts || Date.now());
    changedId = true;
  }
}
if (changedId) saveMatches(matchesAll);
  
  ensureSeasonSystem();
  
  

var activeSeasonId = getActiveSeasonId();
var selectedSeasonId = getSelectedSeasonId();

// Build two views: active (for Rank) and selected (for History)
var activeMatchesAll = [];
var selectedMatchesAll = [];

for (var fi = 0; fi < matchesAll.length; fi++) {
  // If old match has no seasonId, assign to active season (legacy)
  if (!matchesAll[fi].seasonId) matchesAll[fi].seasonId = activeSeasonId;

  if (matchesAll[fi].seasonId === activeSeasonId) activeMatchesAll.push(matchesAll[fi]);
  if (matchesAll[fi].seasonId === selectedSeasonId) selectedMatchesAll.push(matchesAll[fi]);
}

// Persist possible legacy patch
saveMatches(matchesAll);

// From now on:
// - use activeMatchesAll for Rank UI
// - use selectedMatchesAll for History list & stats
  
  // Build season dropdown
var seasons = loadSeasons();
var activeId = getActiveSeasonId();
var select = document.getElementById("seasonSelect");

if (select) {
  select.innerHTML = "";
  for (var si = seasons.length - 1; si >= 0; si--) {
    var s = seasons[si];
    var opt = document.createElement("option");
    var label = (s.name ? s.name : s.id);
    label += " [" + s.id + "]";

    if (s.id === activeId) label += " (Active)";
    if (s.finalRankLabel) label += " ‚Ä¢ " + s.finalRankLabel;

    opt.value = s.id;
    opt.textContent = label;

    select.appendChild(opt);
  }

  select.value = selectedSeasonId || activeId;
}
  // Read-only mode indicator (History viewing non-active season)
var ro = document.getElementById("readOnlyBadge");
var isReadOnly = (selectedSeasonId !== activeSeasonId);
if (ro) ro.style.display = isReadOnly ? "inline-block" : "none";

// Disable destructive season actions when read-only (optional UX)
var renameBtn = document.querySelector('button[onclick="renameSeason()"]');
var deleteBtn = document.querySelector('button[onclick="deleteSeason()"]');
if (renameBtn) renameBtn.disabled = false; // allow rename anytime (your choice)
if (deleteBtn) deleteBtn.disabled = false; // delete already has safety checks

// If you want to block rename/delete while viewing non-active season, uncomment:
// if (renameBtn) renameBtn.disabled = isReadOnly;
// if (deleteBtn) deleteBtn.disabled = isReadOnly;
  
  // Render season summary panel (selected season)
var summaryEl = document.getElementById("seasonSummary");
if (summaryEl) {
  var seasonsList = loadSeasons();
  var selectedMeta = null;
  for (var si = 0; si < seasonsList.length; si++) {
    if (seasonsList[si].id === selectedSeasonId) selectedMeta = seasonsList[si];
  }

  var isActive = (selectedSeasonId === activeSeasonId);

  // Compute current RR/rank for selected season (even if ended, for display consistency)
  var sumRR = 0;
  for (var mi = 0; mi < selectedMatchesAll.length; mi++) sumRR += Number(selectedMatchesAll[mi].rp || 0);
  var currentRR = START_RP + sumRR;
  if (currentRR < MIN_RP) currentRR = MIN_RP;
  var currentRank = getRank(currentRR);

  var stats = computeSeasonStats(selectedMatchesAll);

  var html = "";
  html += "<div class='row'><div class='k'>Season</div><div class='v'>" +
          selectedSeasonId + " " + (isActive ? "<span class='season-tag active'>Active</span>" : "<span class='season-tag'>Ended</span>") +
          "</div></div>";

  html += "<div class='row'><div class='k'>Current Rank</div><div class='v'>" + currentRank.label + "</div></div>";
  html += "<div class='row'><div class='k'>Current RR</div><div class='v'>" + currentRR + "</div></div>";

  if (selectedMeta && !isActive) {
    if (selectedMeta.finalRankLabel) {
      html += "<div class='row'><div class='k'>Final Rank</div><div class='v'>" + selectedMeta.finalRankLabel + "</div></div>";
    }
    if (selectedMeta.finalRR !== null && selectedMeta.finalRR !== undefined) {
      html += "<div class='row'><div class='k'>Final RR</div><div class='v'>" + selectedMeta.finalRR + "</div></div>";
    }
  }

  html += "<div class='row'><div class='k'>Matches</div><div class='v'>" + stats.matchesCount + "</div></div>";
  html += "<div class='row'><div class='k'>Avg RR / match</div><div class='v'>" + stats.avgRR + "</div></div>";
  html += "<div class='row'><div class='k'>Best / Worst</div><div class='v'>" + (stats.bestRR >= 0 ? "+" + stats.bestRR : stats.bestRR) +
          " / " + (stats.worstRR >= 0 ? "+" + stats.worstRR : stats.worstRR) + "</div></div>";
  html += "<div class='row'><div class='k'>Top1 / Top3 / Top7</div><div class='v'>" +
          stats.top1Count + " / " + stats.top3Count + " / " + stats.top7Count + "</div></div>";
  html += "<div class='row'><div class='k'>MVP</div><div class='v'>" + stats.mvpCount + "</div></div>";
  html += "<div class='row'><div class='k'>Teammate Left</div><div class='v'>" + stats.leftCount + "</div></div>";

  summaryEl.innerHTML = html;
}

  // Backfill + recalc rp with current formula
  var changed = false;
  for (var i = 0; i < matchesAll.length; i++) {
    matchesAll[i].breakdown = calcRPBreakdown(matchesAll[i]);
    matchesAll[i].rp = matchesAll[i].breakdown.total;
    changed = true;
  }
  if (changed) saveMatches(matchesAll);

  updateRankUI(activeMatchesAll);

  // Display list: newest first, last 20
  var matches = selectedMatchesAll.slice();
  matches.sort(function(a, b) { return Number(b.ts || 0) - Number(a.ts || 0); });

  var mode = getHistoryLimit(); // "20" or "all"
var MAX_MATCHES = (mode === "all") ? 0 : 20;

if (MAX_MATCHES > 0 && matches.length > MAX_MATCHES) matches = matches.slice(0, MAX_MATCHES);

// Update UI label/button
var toggleBtn = document.getElementById("toggleHistoryBtn");
var hint = document.getElementById("historyHint");
if (toggleBtn) toggleBtn.textContent = (mode === "all") ? "Show last 20" : "Show all";
if (hint) hint.textContent = (mode === "all") ? ("Showing all matches (" +selectedMatchesAll.length + ")") : "Showing last 20 matches";

  var list = document.getElementById("matchList");
  if (!list) return;
  list.innerHTML = "";

  var streakEl = document.getElementById("streakValue");
  var bestEl = document.getElementById("bestValue");
  var worstEl = document.getElementById("worstValue");

  if (selectedMatchesAll.length === 0) {
    var panel = document.createElement("div");
    panel.className = "panel";
    var p = document.createElement("p");
    p.innerHTML = 'No matches yet. Add your first match in <b>ADD MATCH</b>.';
    panel.appendChild(p);
    list.appendChild(panel);

    if (streakEl) streakEl.textContent = "0";
    if (bestEl) bestEl.textContent = "+0";
    if (worstEl) worstEl.textContent = "0";
    return;
  }

  // Best / worst across ALL matches
  var best = -Infinity;
  var worst = Infinity;
  for (var b = 0; b < selectedMatchesAll.length; b++) {
    var rp = Number(selectedMatchesAll[b].rp || 0);
    if (rp > best) best = rp;
    if (rp < worst) worst = rp;
  }
  if (bestEl) bestEl.textContent = best >= 0 ? ("+" + best) : String(best);
  if (worstEl) worstEl.textContent = String(worst);

  // Streak across ALL matches (place <= 3), newest backwards by ts
  var sortedAll = selectedMatchesAll.slice().sort(function(a, b) { return Number(b.ts || 0) - Number(a.ts || 0); });
  var streak = 0;
  for (var s = 0; s < sortedAll.length; s++) {
    if (Number(sortedAll[s].place || 99) <= 3) streak++;
    else break;
  }
  if (streakEl) streakEl.textContent = String(streak);

  // Render visible cards
  for (var idx = 0; idx < matches.length; idx++) {
    var m = matches[idx];

    var card = document.createElement("div");
    card.className = "match-card";
    if (m.rp === best) card.classList.add("best");
    if (m.rp === worst) card.classList.add("worst");

    var row = document.createElement("div");
    row.className = "match-row";

    var left = document.createElement("div");
    left.className = "left";

    var title = document.createElement("div");
    title.className = "title";

    var matchNum = document.createElement("span");
    matchNum.textContent = "Match #" + (idx + 1);
    title.appendChild(matchNum);

    var badges = document.createElement("div");
    badges.className = "badges";

    if (m.mvp) {
      var b1 = document.createElement("span");
      b1.className = "badge-pill badge-mvp";
      b1.textContent = "‚≠ê MVP";
      badges.appendChild(b1);
    }
    if (m.left) {
      var b2 = document.createElement("span");
      b2.className = "badge-pill badge-leave";
      b2.textContent = "‚ö† Teammate Left";
      badges.appendChild(b2);
    }
    title.appendChild(badges);

    var place = document.createElement("div");
    place.className = "place";
    place.innerHTML = "üèÜ Place: <strong>" + m.place + "</strong> / 25 teams";

    var kad = document.createElement("div");
    kad.className = "kad";
    kad.innerHTML =
      "üî´ K/A/D: <strong>" + m.kills + "</strong> / <strong>" + m.assists + "</strong> / <strong>" + m.deaths + "</strong>";

    left.appendChild(title);
    left.appendChild(place);
    var time = document.createElement("div");
    time.className = "kad";
    time.textContent = "üïí " + new Date(Number(m.ts || 0)).toLocaleString();
    left.appendChild(time);
    left.appendChild(kad);

    var rpDelta = document.createElement("div");
    rpDelta.className = "rpDelta " + (m.rp >= 0 ? "rpPlus" : "rpMinus");
    rpDelta.textContent = (m.rp >= 0 ? "+" + m.rp : String(m.rp)) + " RR";

    row.appendChild(left);
    row.appendChild(rpDelta);
    
    

    card.appendChild(row);
    list.appendChild(card);
  }
}
  

  function clampInt(value, min, max, fallback) {
  var n = Number(value);
  if (!isFinite(n)) n = (fallback !== undefined) ? fallback : min;
  n = Math.floor(n);
  if (n < min) n = min;
  if (n > max) n = max;
  return n;
}
  
/* ===== ACTIONS ===== */
function startNewSeason() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var activeId = getActiveSeasonId();

  // Compute final stats for active season
  var allMatches = loadMatches();
  var activeMatches = [];
  for (var i = 0; i < allMatches.length; i++) {
    if (allMatches[i].seasonId === activeId) activeMatches.push(allMatches[i]);
  }

  // Final RR for season = START_RP + sum(rr)
  var sum = 0;
  for (var j = 0; j < activeMatches.length; j++) sum += Number(activeMatches[j].rp || 0);
  var finalRR = START_RP + sum;
  if (finalRR < MIN_RP) finalRR = MIN_RP;

  var finalRank = getRank(finalRR);

  // Close current season
  for (var s = 0; s < seasons.length; s++) {
    if (seasons[s].id === activeId) {
      seasons[s].endAt = Date.now();
      seasons[s].finalRR = finalRR;
      seasons[s].finalRankLabel = finalRank.label;
      seasons[s].stats = computeSeasonStats(activeMatches);
    }
  }

  // Create next season id based on max existing S#
var maxNum = 0;
for (var x = 0; x < seasons.length; x++) {
  var m = String(seasons[x].id || "").match(/^S(\d+)$/);
  if (m) {
    var n = Number(m[1]);
    if (n > maxNum) maxNum = n;
  }
}
var newId = "S" + (maxNum + 1);

  seasons.push({
  id: newId,
  name: newId,
  startAt: Date.now(),
  endAt: null,
  finalRR: null,
  finalRankLabel: null,
  stats: null
});

  saveSeasons(seasons);
  setActiveSeasonId(newId);
  setSelectedSeasonId(newId);

  lastRankState = null;
  renderHistoryFromStorage();

  alert("New season started! RR has been reset for the active season.");
}
  
  function clampNumber(val, min, max, fallback) {
  val = Number(val);
  if (!isFinite(val)) return fallback;
  if (val < min) return min;
  if (val > max) return max;
  return val;
}
  
  function genMatchId(ts) {
  // Unique-enough ID without crypto dependency
  var r = Math.random().toString(16).slice(2);
  return "m_" + String(ts) + "_" + r;
}
  
  function enforceActiveSeasonContext() {
  ensureSeasonSystem();

  var activeId = getActiveSeasonId();
  var selectedId = getSelectedSeasonId();

  if (selectedId && activeId && selectedId !== activeId) {
    setSelectedSeasonId(activeId);
    return false;
  }
  return true;
}
  
  function submitMatch() {
    // Lock RP: prevent adding match while viewing past season
  var okSeason = enforceActiveSeasonContext();
  if (!okSeason) {
    showToast("Switched back to ACTIVE season. Please submit again.", "warn");
    renderHistoryFromStorage();
    return;
  }
   
  const place = clampNumber(document.getElementById("inPlace").value, 1, 25, 25);
  const kills = clampNumber(document.getElementById("inKills").value, 0, 99, 0);
  const assists = clampNumber(document.getElementById("inAssists").value, 0, 99, 0);
  const deaths = clampNumber(document.getElementById("inDeaths").value, 0, 99, 0);
  var mvp = document.getElementById("inMVP").checked;
  var left = document.getElementById("inLeft").checked;
  document.getElementById("inPlace").value = place;
  document.getElementById("inKills").value = kills;
  document.getElementById("inAssists").value = assists;
  document.getElementById("inDeaths").value = deaths;

  var ts = Date.now();
    
  var match = { place: place, kills: kills, assists: assists, deaths: deaths, mvp: mvp, left: left, ts: ts, seasonId: getActiveSeasonId(), matchId: genMatchId(ts) };
  match.breakdown = calcRPBreakdown(match);
  match.rp = match.breakdown.total;

  var matches = loadMatches();
  matches.push(match);
  saveMatches(matches);
    document.getElementById("inKills").value = 0;
    document.getElementById("inAssists").value = 0;
    document.getElementById("inDeaths").value = 1;
    document.getElementById("inMVP").checked = false;
    document.getElementById("inLeft").checked = false;

  renderHistoryFromStorage();

  var btns = document.querySelectorAll(".nav-btn");
  showTab("history", btns[2]);
}

function undoLastMatch() {
  ensureSeasonSystem();

  var activeSeasonId = getActiveSeasonId();
  var matches = loadMatches();

  if (!matches || matches.length === 0) {
    alert("No matches to undo.");
    return;
  }

  // Find newest match ONLY in active season
  var newestIndex = -1;
  var newestTs = -Infinity;

  for (var i = 0; i < matches.length; i++) {
    if (matches[i].seasonId !== activeSeasonId) continue;

    var ts = Number(matches[i].ts || 0);
    if (ts > newestTs) {
      newestTs = ts;
      newestIndex = i;
    }
  }

  if (newestIndex === -1) {
    alert("No matches to undo in the active season.");
    return;
  }

  matches.splice(newestIndex, 1);
  saveMatches(matches);

  lastRankState = null;
  renderHistoryFromStorage();

  var btns = document.querySelectorAll(".nav-btn");
  showTab("history", btns[2]);
}

function resetMatches() {
  if (!confirm("Reset all saved matches?")) return;
  localStorage.removeItem(STORAGE_KEY);
  lastRankState = null;
  renderHistoryFromStorage();
}

  document.addEventListener("click", function(e){
  var t = e.target;
  if (t && t.id === "toggleHistoryBtn") {
    var mode = getHistoryLimit();
    setHistoryLimit(mode === "all" ? "20" : "all");
    renderHistoryFromStorage();
  }
});
  
  document.addEventListener("change", function(e){
  var t = e.target;
  if (t && t.id === "seasonSelect") {
    setSelectedSeasonId(t.value);
    lastRankState = null;
    ensureSeasonSystem();
    renderHistoryFromStorage();
  }
});
function exportData() {
  ensureSeasonSystem();

  var box = document.getElementById("ioBox");

  var payload = {
    version: 2,
    exportedAt: Date.now(),
    seasons: loadSeasons(),
    activeSeasonId: getActiveSeasonId(),
    selectedSeasonId: getSelectedSeasonId(),
    matches: loadMatches()
  };

  var json = JSON.stringify(payload, null, 2);
  if (box) box.value = json;

  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(json).then(function () {
      alert("Exported! Full data copied to clipboard.");
    }).catch(function () {
      alert("Exported! (Clipboard copy was blocked by browser.)");
    });
  } else {
    alert("Exported! (Clipboard API not available.)");
  }
}

function importData() {
  ensureSeasonSystem();

  var box = document.getElementById("ioBox");
  if (!box) {
    alert("Import box not found.");
    return;
  }

  var text = String(box.value || "").trim();
  if (!text) {
    alert("Paste JSON into the box first.");
    return;
  }

  var payload;
  try {
    payload = JSON.parse(text);
  } catch (e) {
    alert("Invalid JSON. Please check formatting.");
    return;
  }

  var seasons = null;
  var activeId = null;
  var selectedId = null;
  var matches = null;

  if (payload && payload.version === 2) {
    seasons = Array.isArray(payload.seasons) ? payload.seasons : null;
    activeId = payload.activeSeasonId;
    selectedId = payload.selectedSeasonId;
    matches = Array.isArray(payload.matches) ? payload.matches : null;
  } else if (Array.isArray(payload)) {
    matches = payload;
  } else if (payload && Array.isArray(payload.matches)) {
    matches = payload.matches;
  }

  if (!matches) {
    alert("Unsupported format. Must be v2 export or { matches: [...] }");
    return;
  }

  if (!seasons || seasons.length === 0 || !activeId) {
    // legacy import: create single season
    activeId = "S1";
    seasons = [{
      id: activeId,
      startAt: Date.now(),
      endAt: null,
      finalRR: null,
      finalRankLabel: null,
      stats: null
    }];
    selectedId = activeId;
  }

  // Clean + normalize matches (ensure seasonId, ts, rp/breakdown)
  var cleaned = [];
  for (var i = 0; i < matches.length; i++) {
    var m = matches[i] || {};

    var place = clampInt(m.place, 1, 25, 25);
    var kills = clampInt(m.kills, 0, 99, 0);
    var assists = clampInt(m.assists, 0, 99, 0);
    var deaths = clampInt(m.deaths, 0, 99, 0);
    var mvp = !!m.mvp;
    var left = !!m.left;
    var ts = Number(m.ts || Date.now());
    var seasonId = m.seasonId ? String(m.seasonId) : String(activeId);

    if (!isFinite(place)) place = 25;
    if (!isFinite(kills)) kills = 0;
    if (!isFinite(assists)) assists = 0;
    if (!isFinite(deaths)) deaths = 0;
    if (!isFinite(ts)) ts = Date.now();

    var obj = {
      place: place,
      kills: kills,
      assists: assists,
      deaths: deaths,
      mvp: mvp,
      left: left,
      ts: ts,
      seasonId: seasonId
    };

    obj.breakdown = calcRPBreakdown(obj);
    obj.rp = obj.breakdown.total;

    cleaned.push(obj);
  }
  
  makeBackup("before import");
  if (!confirm("Import will replace your current saved data (seasons + matches). Continue?")) return;

  saveMatches(cleaned);
  saveSeasons(seasons);

  setActiveSeasonId(activeId);

  var validSelected = false;
  for (var s = 0; s < seasons.length; s++) {
    if (seasons[s].id === selectedId) validSelected = true;
  }
  setSelectedSeasonId(validSelected ? selectedId : activeId);

  lastRankState = null;
  renderHistoryFromStorage();

  var btns = document.querySelectorAll(".nav-btn");
  showTab("history", btns[2]);

  alert("Import complete!");
}

function clearIO() {
  var box = document.getElementById("ioBox");
  if (box) box.value = "";
}
  function renameSeason() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var selectedId = getSelectedSeasonId();

  var season = null;
  for (var i = 0; i < seasons.length; i++) {
    if (seasons[i].id === selectedId) season = seasons[i];
  }
  if (!season) {
    alert("Season not found.");
    return;
  }

  var currentName = season.name || season.id;
  var next = prompt("Enter season name:", currentName);
  if (next === null) return;

  next = String(next).trim();
  if (!next) {
    alert("Name cannot be empty.");
    return;
  }
  if (next.length > 40) {
    alert("Name too long (max 40 chars).");
    return;
  }

  season.name = next;
  saveSeasons(seasons);
  renderHistoryFromStorage();
}

function deleteSeason() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var selectedId = getSelectedSeasonId();
  var activeId = getActiveSeasonId();

  if (selectedId === activeId) {
    alert("You can't delete the active season. Start a new season first, then delete the old one.");
    return;
  }

  // Only allow deleting ended seasons (safety)
  var season = null;
  for (var i = 0; i < seasons.length; i++) {
    if (seasons[i].id === selectedId) season = seasons[i];
  }
  if (!season) {
    alert("Season not found.");
    return;
  }
  if (!season.endAt) {
    alert("You can only delete ended seasons.");
    return;
  }

  if (!confirm("Delete season " + selectedId + " and all its matches? This cannot be undone.")) return;

  // Remove season
  var nextSeasons = [];
  for (var s = 0; s < seasons.length; s++) {
    if (seasons[s].id !== selectedId) nextSeasons.push(seasons[s]);
  }
  saveSeasons(nextSeasons);

  // Remove matches for that season
  var matches = loadMatches();
  var kept = [];
  for (var m = 0; m < matches.length; m++) {
    if (matches[m].seasonId !== selectedId) kept.push(matches[m]);
  }
  saveMatches(kept);

  // After delete, set selected season back to active
  setSelectedSeasonId(activeId);

  lastRankState = null;
  renderHistoryFromStorage();

  alert("Season deleted.");
}
  function renumberSeasonIds() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var matches = loadMatches();

  if (!seasons || seasons.length === 0) {
    alert("No seasons found.");
    return;
  }

  if (!confirm("This will rename season IDs to S1, S2, S3... and update all matches. Continue?")) return;

  // Sort seasons by start time (oldest first)
  seasons.sort(function(a, b) {
    return Number(a.startAt || 0) - Number(b.startAt || 0);
  });

  // Build mapping oldId -> newId
  var map = {};
  for (var i = 0; i < seasons.length; i++) {
    var oldId = seasons[i].id;
    var newId = "S" + (i + 1);
    map[oldId] = newId;

    seasons[i].id = newId;

    // Default name if empty
    if (!seasons[i].name) seasons[i].name = newId;
  }

  // Update matches seasonId
  for (var m = 0; m < matches.length; m++) {
    var old = matches[m].seasonId;
    if (old && map[old]) matches[m].seasonId = map[old];
  }

  // Update active/selected IDs
  var activeOld = getActiveSeasonId();
  var selectedOld = getSelectedSeasonId();

  if (activeOld && map[activeOld]) setActiveSeasonId(map[activeOld]);
  if (selectedOld && map[selectedOld]) setSelectedSeasonId(map[selectedOld]);

  saveSeasons(seasons);
  saveMatches(matches);

  lastRankState = null;
  renderHistoryFromStorage();

  alert("Season IDs renumbered successfully.");
}
  document.addEventListener("click", function(e){
  var t = e.target;
    // Edit match button (active season)
if (t && t.getAttribute && t.getAttribute("data-edit-id")) {
  var idEdit = String(t.getAttribute("data-edit-id") || "");
  if (!idEdit) return;

  ensureSeasonSystem();
  var activeId = getActiveSeasonId();

  var matches = loadMatches();
  var found = null;
  for (var i = 0; i < matches.length; i++) {
    if (matches[i].seasonId === activeId && String(matches[i].matchId) === idEdit) {
      found = matches[i];
      break;
    }
  }

  if (!found) {
    alert("Match not found (or not in active season).");
    return;
  }

  // Fill form inputs
  document.getElementById("inPlace").value = found.place;
  document.getElementById("inKills").value = found.kills;
  document.getElementById("inAssists").value = found.assists;
  document.getElementById("inDeaths").value = found.deaths;
  document.getElementById("inMVP").checked = !!found.mvp;
  document.getElementById("inLeft").checked = !!found.left;

  editingMatchId = found.ts;

  var saveBtn = document.getElementById("saveEditBtn");
  if (saveBtn) saveBtn.style.display = "inline-block";

  // Go to ADD tab
  var btns = document.querySelectorAll(".nav-btn");
  showTab("add", btns[3]);

  return;
}

  // Delete match button
  if (t && t.classList && t.classList.contains("btn-mini") && t.classList.contains("danger") && t.getAttribute("data-ts")) {
    var ts = Number(t.getAttribute("data-ts"));
    if (!isFinite(ts)) return;

    ensureSeasonSystem();
    var activeId = getActiveSeasonId();
    
    makeBackup("before delete match");
    if (!confirm("Delete this match from the active season? This cannot be undone.")) return;

    var matches = loadMatches();
    var kept = [];
    var removed = false;

    for (var i = 0; i < matches.length; i++) {
      // Only allow deleting from active season
      if (matches[i].seasonId === activeId && Number(matches[i].ts) === ts) {
        removed = true;
        continue;
      }
      kept.push(matches[i]);
    }

    if (!removed) {
      alert("Match not found (or not in active season).");
      return;
    }

    saveMatches(kept);
    lastRankState = null;
    preloadSfx();
    renderHistoryFromStorage();
  }
});
  
  preloadRankBadges();
  // =============================


  // =============================
// DIGITAL RIFT PROTOCOL - PUBLIC API (SAFE)
// Always defines window.showRankUp / window.showTierUp
// =============================

function _ruGetRoot() {
  return document.getElementById("rankup");
}

function _ruSetPhase(root, phase) {
  root.dataset.phase = phase;
  
}

function _ruSetOpen(root, isOpen) {
  root.classList.toggle("is-open", isOpen);
  root.setAttribute("aria-hidden", isOpen ? "false" : "true");
}

function _ruTierKeyFromText(t) {
  return String(t || "").trim().split(" ")[0].toLowerCase();
}

function _ruIsTopRankText(toText) {
  const t = String(toText || "").toUpperCase();
  return t.includes("NEXUS") || t.includes("ABSOLUTE") || t.includes("ELITE");
}

function _ruFill(payload) {
  const root = _ruGetRoot();
  if (!root) return null;

  const subEl = document.getElementById("rankupSub");
  const rightEl = document.getElementById("rankupRight");
  const oldLabelEl = document.getElementById("rankupOldLabel");
  const newLabelEl = document.getElementById("rankupNewLabel");
  const oldImg = document.getElementById("rankupOldImg");
  const newImg = document.getElementById("rankupNewImg");
  const btn = document.getElementById("rankupContinue");

  const fromText = payload?.fromText || "";
  const toText = payload?.toText || "";
  const rrText = payload?.rrText || "";

  if (oldLabelEl) oldLabelEl.textContent = fromText;
  if (newLabelEl) newLabelEl.textContent = toText;

  if (subEl) subEl.textContent = payload?.subText || subEl.textContent;
  if (rightEl) rightEl.textContent = rrText;

  if (oldImg) oldImg.src = "assets/ranks/" + _ruTierKeyFromText(fromText) + ".webp";
  if (newImg) newImg.src = "assets/ranks/" + _ruTierKeyFromText(toText) + ".webp";
  if (oldImg) oldImg.onerror = function(){ oldImg.removeAttribute("src"); };
  if (newImg) newImg.onerror = function(){ newImg.removeAttribute("src"); };

  if (btn) btn.style.display = "none";

  return { root, btn, toText };
}

function _ruRunTimeline(root, steps) {
  let i = 0;
  function next() {
    if (i >= steps.length) return;
    const s = steps[i++];
    _ruSetPhase(root, s.phase);
    if (s.ms != null) _ruLater(next, s.ms);
  }
  next();
}

  var _ruTimers = [];

function _ruLater(fn, ms) {
  var id = setTimeout(fn, ms);
  _ruTimers.push(id);
  return id;
}

function _ruClearTimers() {
  while (_ruTimers.length) clearTimeout(_ruTimers.pop());
}
  
window.hideRankUp = function () {
  _ruClearTimers();

  // Avoid aria-hidden warning: remove focus from inside overlay before hiding
  try { document.activeElement && document.activeElement.blur(); } catch(e) {}

  const root = _ruGetRoot();
  if (!root) return;

  _ruSetOpen(root, false);
  _ruSetPhase(root, "idle");

  const btn = document.getElementById("rankupContinue");
  if (btn) btn.style.display = "none";
};

window.showRankUp = function (payload) {
  window.hideRankUp();
  // Force a clean restart on next frame

  const res = _ruFill(payload);
  if (!res) return;

  const { root, btn, toText } = res;

  root.dataset.type = "rank";
  root.dataset.top = _ruIsTopRankText(toText) ? "1" : "0";

  requestAnimationFrame(() => {
  _ruSetOpen(root, true);
  _ruRunTimeline(root, timeline);
});
  

  const timeline = [
    { phase: "open", ms: 1000 },
    { phase: "collapse", ms: 700 },
    { phase: "impact", ms: 280 },
    { phase: "reveal", ms: 1050 },
    { phase: "done", ms: null }
  ];

  _ruRunTimeline(root, timeline);

  // show CTA near done
  if (btn) {
    _ruLater(() => { if (btn) btn.style.display = "inline-block"; }, 1000 + 700 + 280 + 1050 - 200);
  }
};

window.showTierUp = function (payload) {
  window.hideRankUp();

  const res = _ruFill(payload);
  if (!res) return;
  const { root } = res;

  root.dataset.type = "tier";
  root.dataset.top = "0";

  requestAnimationFrame(() => {
  _ruSetOpen(root, true);
  _ruRunTimeline(root, timeline);
});
  

  const timeline = [
    { phase: "impact", ms: 220 },
    { phase: "reveal", ms: 650 },
    { phase: "done", ms: 350 }
  ];

  _ruRunTimeline(root, timeline);

  // auto close tier-up
  _ruLater(() => window.hideRankUp(), 1400);
};

// Close UX
document.addEventListener("keydown", function (e) {
  if (e.key === "Escape") window.hideRankUp();
});

document.addEventListener("click", function (e) {
  const t = e.target;
  if (t && t.id === "rankupContinue") window.hideRankUp();
});
  
/* ===== INIT ===== */
renderHistoryFromStorage();
</script>
  <!-- ===== END OF JAVASCRIPT ===== -->
<!-- ===== RANKUP OVERLAY (Digital Rift Protocol / Desktop) ===== -->
<div class="rankup" id="rankup" aria-hidden="true" data-phase="idle" data-type="rank" data-top="0">
  <div class="rankup__veil"></div>
  <div class="rankup__grain" aria-hidden="true"></div>

  <div class="rankup__stage" role="dialog" aria-label="Rank up cinematic">
    <div class="rankup__scan" aria-hidden="true"></div>
    <div class="rankup__burst" aria-hidden="true"></div>
    <div class="rankup__flash" aria-hidden="true"></div>
    <div class="rankup__beams" aria-hidden="true"></div>
    <div class="rankup__chroma" aria-hidden="true"></div>
    <div class="rankup__shards" aria-hidden="true"></div>

    <!-- Top HUD -->
    <header class="rankup__hud">
      <div class="rankup__hudLeft">
        <div class="rankup__kicker">RANKED UPDATE</div>
        <div class="rankup__sub" id="rankupSub">Protocol: Digital Rift ‚Ä¢ Opening breach‚Ä¶</div>
      </div>
      <div class="rankup__hudRight" id="rankupRight">NEW RANK UNLOCKED</div>
    </header>

    <!-- Rift -->
    <div class="rankup__riftWrap" aria-hidden="true">
      <div class="rankup__rift">
        <div class="rankup__riftEdge"></div>
      </div>
    </div>

    <!-- Emblems -->
    <div class="rankup__emblems">
      <!-- OLD -->
      <div class="rankup__emblem rankup__emblem--old" id="rankupOld">
        <div class="rankup__badge">
          <img class="rankup__img" id="rankupOldImg" alt="Old rank badge" />
          <span class="rankup__label" id="rankupOldLabel">RANK 6 / T3</span>
        </div>
      </div>

      <!-- NEW -->
      <div class="rankup__emblem rankup__emblem--new" id="rankupNew">
        <div class="rankup__badge rankup__badge--new">
          <img class="rankup__img" id="rankupNewImg" alt="New rank badge" />
          <span class="rankup__label" id="rankupNewLabel">RANK 7 / T1</span>
        </div>
      </div>
    </div>

    <!-- CTA -->
    <footer class="rankup__cta">
      <button class="rankup__btn" id="rankupContinue" type="button">Continue</button>
    </footer>
  </div>
</div>
  
<!-- ===== END OF UI ===== -->
</body>
</html>
