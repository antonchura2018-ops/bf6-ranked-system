<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>BF6 Ranked System</title>

<!-- ============================= -->
<!-- ===== GLOBAL STYLES (CSS) === -->
<!-- ============================= -->
<style>
  /* ====== CINEMATIC OVERLAY ====== */
.cinematic{
  position: fixed;
  inset: 0;
  z-index: 9999;
  display:flex;
  align-items:center;
  justify-content:center;

    --cin-intensity: 1;          /* 1..10 */
  --cin-burst: 0.25;           /* 0..1 */
  --cin-shake: 0px;            /* px */
  --cin-ring-speed: 2.2s;      /* time */
  --cin-particles: 18;         /* count */
  --cin-duration: 2400ms;      /* auto-hide */

}

.cinematic.hidden{ display:none; }

.cinematic-bg{
  position:absolute;
  inset:0;
  background:
    radial-gradient(circle at 30% 30%, rgba(34,211,238,0.18), transparent 55%),
    radial-gradient(circle at 70% 70%, rgba(167,139,250,0.12), transparent 60%),
    radial-gradient(circle at 50% 50%, rgba(0,0,0,0.85), rgba(0,0,0,0.95));
  backdrop-filter: blur(8px);
  animation: cinFade 0.35s ease;
}
  /* Epic burst layer (scales with intensity) */
.cinematic-bg::after{
  content:"";
  position:absolute;
  inset:-40%;
  background:
    radial-gradient(circle at 50% 45%,
      color-mix(in srgb, var(--cin-accent, #22d3ee) 55%, transparent) 0%,
      transparent 60%
    ),
    radial-gradient(circle at 50% 55%,
      color-mix(in srgb, var(--cin-accent, #22d3ee) 35%, transparent) 0%,
      transparent 70%
    );
  opacity: var(--cin-burst, 0.25);
  filter: blur(2px);
  transform: scale(calc(0.92 + (var(--cin-intensity, 1) * 0.012)));
  pointer-events:none;
  animation: cinBurstPulse 520ms ease;
}

@keyframes cinBurstPulse{
  0%{ opacity: 0; transform: scale(0.90); }
  45%{ opacity: var(--cin-burst, 0.25); transform: scale(1.03); }
  100%{ opacity: calc(var(--cin-burst, 0.25) * 0.55); transform: scale(1.00); }
}


@keyframes cinFade{
  from { opacity:0; }
  to { opacity:1; }
}

.cinematic-card{
  position:relative;
  width:min(720px, 92vw);
  padding: 34px 28px;
  border-radius: 22px;
  background: linear-gradient(135deg, rgba(2,6,23,0.85), rgba(15,23,42,0.85));
  border: 1px solid rgba(255,255,255,0.07);
    box-shadow: 0 0 calc(60px + (var(--cin-intensity, 1) * 10px))
    color-mix(in srgb, var(--cin-accent, #22d3ee) 18%, rgba(0,0,0,0));
  overflow:hidden;
  transform: translateZ(0);
}
  
  .cin-wrap{
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
  /* Shake helper (intensity-controlled) */
.cinematic[data-shake="1"] .cin-wrap{
  animation: cinShake 420ms ease;
}

@keyframes cinShake{
  0%{ transform: translateY(0) translateX(0) scale(1); }
  25%{ transform: translateY(0) translateX(calc(var(--cin-shake, 0px) * -1)) scale(1); }
  55%{ transform: translateY(0) translateX(var(--cin-shake, 0px)) scale(1); }
  80%{ transform: translateY(0) translateX(calc(var(--cin-shake, 0px) * -0.5)) scale(1); }
  100%{ transform: translateY(0) translateX(0) scale(1); }
}

.cinematic-card::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius: 22px;
  padding: 2px;
  background: linear-gradient(120deg, rgba(34,211,238,0.95), rgba(56,189,248,0.0), rgba(167,139,250,0.75));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: .55;
  filter: drop-shadow(0 0 20px rgba(34,211,238,0.25));
}

.cinematic-title{
  font-size: 26px;
  font-weight: 900;
  letter-spacing: 1.2px;
  background: linear-gradient(90deg, #22d3ee, #a78bfa);
  -webkit-background-clip:text;
  -webkit-text-fill-color: transparent;
  text-transform: uppercase;
}

.cinematic-sub{
  margin-top: 10px;
  color:#cbd5e1;
  letter-spacing: .6px;
  opacity: .9;
}

.cinematic-emblem{
  margin-top: 22px;
  width: 160px;
  height: 160px;
  position: relative;
}

.cin-ring{
  position:absolute;
  inset:-18px;
  border-radius: 50%;
  background: conic-gradient(from 0deg, transparent, rgba(34,211,238,0.9), transparent, rgba(167,139,250,0.7), transparent);
  animation: spin var(--cin-ring-speed, 2.2s) linear infinite;
  box-shadow: 0 0 30px rgba(34,211,238,0.25);
}

.cin-core{
  position:absolute;
  inset: 24px;
  border-radius: 50%;
    background: radial-gradient(
  circle at 30% 30%,
  color-mix(in srgb, var(--cin-accent, #22d3ee) 55%, white),
  var(--cin-accent, #22d3ee) 45%,
  #020617 72%
);
  box-shadow: 0 0 40px rgba(34,211,238,0.5);
}

.cin-hint{
  margin-top: 18px;
  font-size: 12px;
  color:#9ca3af;
  opacity: .8;
}
  /* ====== CINEMATIC MODES + PARTICLES ====== */
.cinematic{ --cin-accent: #22d3ee; }

.cinematic[data-mode="up"] .cinematic-card{
  box-shadow: 0 0 90px rgba(34,211,238,0.18);
}

.cinematic[data-mode="down"] .cinematic-card{
  box-shadow: 0 0 90px rgba(251,113,133,0.16);
}

/* Background pulse stronger depending on mode */
.cinematic[data-mode="up"] .cinematic-bg{
  animation: cinFade 0.25s ease, bgPulseUp 1.2s ease forwards;
}
@keyframes bgPulseUp{
  0%{ filter: saturate(1) brightness(1); }
  35%{ filter: saturate(1.35) brightness(1.15); }
  100%{ filter: saturate(1.05) brightness(1.02); }
}

.cinematic[data-mode="down"] .cinematic-bg{
  animation: cinFade 0.25s ease, bgPulseDown 1.1s ease forwards;
}
@keyframes bgPulseDown{
  0%{ filter: saturate(1) brightness(1); }
  40%{ filter: saturate(1.2) brightness(0.95); }
  100%{ filter: saturate(1.05) brightness(1.0); }
}

/* Card entrance animation differs */
.cinematic[data-mode="up"] .cinematic-card{
  animation: popUp 520ms cubic-bezier(.2,.9,.2,1);
}
@keyframes popUp{
  0% { transform: translateY(18px) scale(0.96); opacity:0; }
  55%{ transform: translateY(-2px) scale(1.02); opacity:1; }
  100%{ transform: translateY(0) scale(1); opacity:1; }
}

.cinematic[data-mode="down"] .cinematic-card{
  animation: popDown 520ms cubic-bezier(.2,.9,.2,1);
}
@keyframes popDown{
  0% { transform: translateY(-10px) scale(0.98); opacity:0; }
  55%{ transform: translateY(10px) scale(1.00); opacity:1; }
  100%{ transform: translateY(0) scale(1); opacity:1; }
}

/* Emblem ring speed changes */
.cinematic[data-mode="up"] .cin-ring{ animation-duration: 1.6s; }
.cinematic[data-mode="down"] .cin-ring{ animation-duration: 2.6s; opacity: .85; }

/* Demotion adds red flash */
.cinematic[data-mode="down"] .cinematic-card::before{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius: 22px;
  background: radial-gradient(circle at 50% 35%, rgba(251,113,133,0.20), transparent 60%);
  opacity: .9;
  pointer-events:none;
  animation: redFlash 420ms ease;
}
@keyframes redFlash{
  0%{ opacity:0; transform: scale(0.98); }
  55%{ opacity:1; transform: scale(1.02); }
  100%{ opacity:0.35; transform: scale(1); }
}

/* Particles container */
.cin-particles{
  position:absolute;
  inset:0;
  pointer-events:none;
}

/* Particle */
.cin-particle{
  position:absolute;
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: var(--cin-accent, rgba(34,211,238,0.95));
  box-shadow: 0 0 18px color-mix(in srgb, var(--cin-accent, #22d3ee) 55%, transparent);
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.6);
  animation: particleFly 850ms ease-out forwards;
}
@keyframes particleFly{
  0%{ opacity: 0; transform: translate(-50%,-50%) scale(0.6); }
  18%{ opacity: 0.95; }
  100%{
    opacity: 0;
    transform:
      translate(calc(-50% + var(--dx)), calc(-50% + var(--dy)))
      scale(0.9);
  }
}


  /* ====== FORM (ADD MATCH) ====== */
.form .grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 12px;
  max-width: 620px;
}

.form label{
  display:flex;
  flex-direction:column;
  gap: 8px;
  font-size: 12px;
  color:#cbd5e1;
  letter-spacing: .3px;
}

.form input[type="number"]{
  padding: 12px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(2,6,23,0.55);
  color:#e5e7eb;
  outline: none;
}

.form input[type="number"]:focus{
  border-color: rgba(34,211,238,0.35);
  box-shadow: 0 0 18px rgba(34,211,238,0.08);
}

.toggles{
  margin-top: 14px;
  display:flex;
  gap: 12px;
  flex-wrap: wrap;
}

.toggle{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(2,6,23,0.45);
  color:#e5e7eb;
  font-size: 12px;
}

.toggle input{ transform: scale(1.1); }

.actions{
  margin-top: 16px;
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap: wrap;
}

.btn{
  padding: 10px 14px;
  border-radius: 12px;
  border: 1px solid rgba(34,211,238,0.35);
  background: rgba(34,211,238,0.14);
  color:#a5f3fc;
  cursor:pointer;
  font-weight: 700;
  letter-spacing: .3px;
}

.btn:hover{
  background: rgba(34,211,238,0.22);
}

.btn.ghost{
  border-color: rgba(251,113,133,0.35);
  background: rgba(251,113,133,0.10);
  color:#fecdd3;
}

.btn.ghost:hover{
  background: rgba(251,113,133,0.16);
}

.hint{
  font-size: 12px;
  color:#9ca3af;
  opacity: .9;
}

  /* ====== MATCH HISTORY UI ====== */
.history-top{
  margin-top: 22px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  max-width: 900px;
}
  .season-summary{
  margin-top: 14px;
  max-width: 1100px;
  background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(2,6,23,.9));
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 14px;
  padding: 14px 16px;
  box-shadow: 0 0 24px rgba(34,211,238,0.05);
}

.season-summary .row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
  padding: 6px 0;
  border-bottom: 1px solid rgba(255,255,255,0.06);
}

.season-summary .row:last-child{ border-bottom:none; }

.season-summary .k{
  color:#9ca3af;
  font-size: 12px;
  letter-spacing: .4px;
}

.season-summary .v{
  color:#e5e7eb;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: .4px;
}

.season-tag{
  display:inline-block;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(2,6,23,0.55);
  font-size: 11px;
  color:#cbd5e1;
}
.season-tag.active{
  border-color: rgba(34,211,238,0.30);
  color:#a5f3fc;
}
  .history-controls{
  margin-top: 16px;
  max-width: 900px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
}
  .season-select{
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(2,6,23,0.55);
  color:#e5e7eb;
  outline:none;
  font-size: 12px;
}
  .ro-badge{
  display:inline-block;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.78);
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .12em;
}
  
.season-select:focus{
  border-color: rgba(34,211,238,0.35);
  box-shadow: 0 0 18px rgba(34,211,238,0.08);
}

.mini-card{
  padding: 14px 16px;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(2,6,23,.9));
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 0 24px rgba(34,211,238,0.05);
}

.mini-label{
  font-size: 12px;
  color:#9ca3af;
  letter-spacing: .8px;
}

.mini-value{
  margin-top: 6px;
  font-size: 22px;
  font-weight: 800;
  color:#22d3ee;
  text-shadow: 0 0 10px rgba(34,211,238,0.25);
}

.match-list{
  margin-top: 16px;
  display: grid;
  gap: 12px;
  max-width: 900px;
}

.match-card{
  position: relative;
  padding: 16px 16px;
  border-radius: 16px;
  background: linear-gradient(135deg, rgba(2,6,23,.85), rgba(15,23,42,.85));
  border: 1px solid rgba(255,255,255,0.06);
  overflow: hidden;
  transition: transform .2s ease, border-color .2s ease, box-shadow .2s ease;
}

.match-card:hover{
  transform: translateY(-1px);
  border-color: rgba(34,211,238,0.18);
  box-shadow: 0 0 28px rgba(34,211,238,0.06);
}

.match-card.best{
  border-color: rgba(34,211,238,0.55);
  box-shadow: 0 0 34px rgba(34,211,238,0.10);
}

.match-card.worst{
  border-color: rgba(251,113,133,0.45);
  box-shadow: 0 0 34px rgba(251,113,133,0.08);
}

.match-row{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.left{
  display:flex;
  flex-direction: column;
  gap: 6px;
}

.title{
  display:flex;
  align-items:center;
  gap:10px;
  font-weight: 800;
  letter-spacing: .8px;
}

.place{
  font-size: 12px;
  color:#9ca3af;
}

.kad{
  font-size: 12px;
  color:#9ca3af;
}
  .breakdown{
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.06);
  background: rgba(2,6,23,0.42);
}

.break-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  font-size: 12px;
  color:#9ca3af;
  padding: 2px 0;
}

.break-row strong{
  color:#e5e7eb;
  font-weight: 800;
}

.break-row .pos{ color: #22c55e; }
.break-row .neg{ color: #fb7185; }

.break-total{
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid rgba(255,255,255,0.06);
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-size: 12px;
  letter-spacing: .4px;
}

.break-total span{
  color:#cbd5e1;
  font-weight: 800;
}

.rpDelta{
  font-size: 18px;
  font-weight: 900;
  min-width: 90px;
  text-align: right;
}
  .match-actions{
  display:flex;
  gap:8px;
  justify-content:flex-end;
  margin-top:10px;
}

.btn-mini{
  padding: 6px 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.85);
  cursor: pointer;
  font-size: 12px;
  font-weight: 700;
}

.btn-mini:hover{
  background: rgba(255,255,255,0.10);
  border-color: rgba(255,255,255,0.18);
}

.btn-mini.danger{
  border-color: rgba(251,113,133,0.35);
  background: rgba(251,113,133,0.10);
  color:#fecdd3;
}
.btn-mini.danger:hover{
  background: rgba(251,113,133,0.16);
}

.rpPlus{ color:#22c55e; text-shadow: 0 0 12px rgba(34,197,94,0.15); }
.rpMinus{ color:#fb7185; text-shadow: 0 0 12px rgba(251,113,133,0.15); }

.badges{
  display:flex;
  gap:8px;
  flex-wrap: wrap;
}

.badge-pill{
  font-size: 11px;
  letter-spacing: .6px;
  padding: 5px 9px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(2,6,23,0.55);
  color:#e5e7eb;
  opacity: .95;
}

.badge-mvp{
  border-color: rgba(251,191,36,0.35);
  box-shadow: 0 0 14px rgba(251,191,36,0.10);
  color:#fbbf24;
}

.badge-leave{
  border-color: rgba(251,113,133,0.35);
  box-shadow: 0 0 14px rgba(251,113,133,0.10);
  color:#fb7185;
}

  /* ====== RANK LADDER ====== */
.ladder{
  margin-top: 28px;
  max-width: 1100px;
  margin: 28px auto 0;
}

.ladder-head{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  margin-bottom: 12px;
}

.ladder-head h3{
  font-size: 18px;
  letter-spacing: .6px;
  color:#e5e7eb;
}

.ladder-note{
  font-size: 12px;
  color:#9ca3af;
  opacity:.9;
}

.ladder-list{
  display: grid;
  gap: 14px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.ladder-item{
  position:relative;
  display:flex;
  gap: 14px;
  align-items:center;
  padding: 14px 16px;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(2,6,23,.9));
  border: 1px solid rgba(255,255,255,0.06);
  overflow:hidden;
  transition: transform .2s ease, border-color .2s ease, box-shadow .2s ease;
}

.ladder-item:hover{
  transform: translateY(-1px);
  border-color: rgba(34,211,238,0.18);
  box-shadow: 0 0 26px rgba(34,211,238,0.06);
}

.ladder-item.locked{
  opacity: .35;
  filter: grayscale(0.35);
}

.ladder-item.unlocked{
  opacity: 1;
}

.ladder-item.current{
  border-color: rgba(34,211,238,0.55);
  box-shadow: 0 0 34px rgba(34,211,238,0.10);
}

.ladder-item.current::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius: 14px;
  padding: 2px;
  background: linear-gradient(120deg, rgba(34,211,238,0.95), rgba(56,189,248,0.0), rgba(34,211,238,0.75));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: .55;
  filter: drop-shadow(0 0 14px rgba(34,211,238,0.25));
  pointer-events:none;
}

.badge{
  width: 56px;
  height: 56px;
  border-radius: 16px;
  position:relative;
  overflow:hidden;
  box-shadow: 0 0 16px rgba(0,0,0,.35);
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: transparent;
}
  /* Ladder badge states (images) */
.ladder-item.locked .badge{
  filter: grayscale(1) brightness(0.35);
  opacity: 0.35;
}

.ladder-item.unlocked .badge{
  filter: grayscale(0.15) brightness(0.9);
  opacity: 0.9;
}

.ladder-item.current .badge{
  filter: grayscale(0) brightness(1.05);
  opacity: 1;
}

.badge::before{
  content:"";
  position:absolute;
  inset:-16px;
  background: conic-gradient(from 0deg, rgba(255,255,255,0.0), rgba(255,255,255,0.55), rgba(255,255,255,0.0));
  opacity:.25;
  animation: spin 7s linear infinite;
}

.meta .name{
  font-size: 14px;
  letter-spacing: 1px;
  font-weight: 700;
  color:#e5e7eb;
}

.meta .desc{
  margin-top: 2px;
  font-size: 12px;
  color:#9ca3af;
}
  @media (max-width: 980px){
  .ladder-list{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}
@media (max-width: 640px){
  .ladder-list{ grid-template-columns: 1fr; }
}

/* ====== BADGE COLORS (Neon identity) ====== */
.b-outcast   { background: radial-gradient(circle at 30% 30%, #ffb86b, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(255,146,76,.35); }
.b-vanguard  { background: radial-gradient(circle at 30% 30%, #22d3ee, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(34,211,238,.35); }
.b-sentinel  { background: radial-gradient(circle at 30% 30%, #38bdf8, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(56,189,248,.35); }
.b-phantom   { background: radial-gradient(circle at 30% 30%, #a78bfa, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(167,139,250,.35); }
.b-warlord   { background: radial-gradient(circle at 30% 30%, #fb7185, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(251,113,133,.35); }
.b-archon    { background: radial-gradient(circle at 30% 30%, #fbbf24, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(251,191,36,.35); }
.b-overseer  { background: radial-gradient(circle at 30% 30%, #2dd4bf, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(45,212,191,.35); }
.b-ascendant { background: radial-gradient(circle at 30% 30%, #60a5fa, #0b1220 55%, #020617 85%); box-shadow: 0 0 18px rgba(96,165,250,.35); }
.b-paragon   { background: radial-gradient(circle at 30% 30%, #e5e7eb, #111827 55%, #020617 85%); box-shadow: 0 0 18px rgba(229,231,235,.25); }
.b-nexus     { background: radial-gradient(circle at 30% 30%, #ff3b3b, #0b0f1a 55%, #020617 85%); box-shadow: 0 0 22px rgba(255,59,59,.40); }

.ladder-item.nexus{
  border-color: rgba(255,59,59,0.25);
}

/* ====== GLOBAL ====== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Segoe UI', sans-serif;
}

body {
  background: radial-gradient(circle at top, #0b0f1a, #05070d);
  color: #e5e7eb;
  min-height: 100vh;
}

/* ====== NAV BAR ====== */
.navbar {
  display: flex;
  justify-content: center;
  gap: 30px;
  padding: 20px;
  background: linear-gradient(180deg, #0f172a, #020617);
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.nav-btn {
  background: transparent;
  border: none;
  color: #9ca3af;
  font-size: 15px;
  letter-spacing: 1px;
  cursor: pointer;
  padding: 10px 20px;
  position: relative;
  transition: color 0.3s;
}

.nav-btn:hover { color: #38bdf8; }
.nav-btn.active { color: #22d3ee; }

.nav-btn.active::after {
  content: '';
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40%;
  height: 2px;
  background: linear-gradient(90deg, #22d3ee, #38bdf8);
  box-shadow: 0 0 12px #22d3ee;
}

/* ====== CONTENT ====== */
.section {
  display: none;
  padding: 50px;
  animation: fade 0.4s ease;
  max-width: 1200px;
  margin: 0 auto;
}
.section.active { display: block; }

@keyframes fade {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ====== HEADERS ====== */
h1 {
  font-size: 32px;
  margin-bottom: 10px;
  background: linear-gradient(90deg, #22d3ee, #38bdf8);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

p { color: #9ca3af; }

/* ====== PANELS ====== */
.panel {
  margin-top: 30px;
  background: linear-gradient(180deg, #0f172a, #020617);
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 14px;
  padding: 25px;
  box-shadow: 0 0 25px rgba(34,211,238,0.05);
}

/* ====== RANK CARD (BASE) ====== */
.rank-card {
  margin-top: 40px;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  gap: 18px;
  padding: 40px 28px;
  background: linear-gradient(135deg, #020617, #0f172a);
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow: 0 0 40px rgba(56,189,248,0.15);
  width: 100%;
max-width: 1100px;
margin: 32px auto 20px;

  position: relative;
  overflow: hidden;
  transition: transform 0.25s ease;
}

.rank-card:hover { transform: translateY(-2px); }

.rank-icon {
  width: 260px;
  height: 260px;
  border-radius: 50%;
  position: relative;
  overflow: hidden;
  box-shadow: 0 0 25px color-mix(in srgb, var(--rank-accent, #22d3ee) 75%, transparent);
  background: transparent;
}
  .rank-icon img{
  position: absolute;
  inset: 10px;
  width: calc(100% - 20px);
  height: calc(100% - 20px);
  object-fit: contain;
  z-index: 2;
  pointer-events: none;
  filter: drop-shadow(0 0 18px rgba(255,255,255,0.35));
}

.rank-glow {
  position: absolute;
  inset: -20px;
  background: conic-gradient(from 0deg, transparent, #38bdf8, transparent);
  animation: spin 6s linear infinite;
  z-index: 1;
  pointer-events: none;
}

@keyframes spin { to { transform: rotate(360deg); } }

.rank-info h2 {
  font-size: 44px;
  letter-spacing: 1.2px;
  margin-bottom: 8px;
  background: linear-gradient(90deg, #38bdf8, #22d3ee);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.rank-rp { font-size: 16px; color: #cbd5e1; }

/* ====== RP BAR ====== */
.rp-bar {
  margin: 14px auto 0;
  width: min(520px, 92vw);
  height: 12px;
  background: #020617;
  border-radius: 10px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.08);
}

.rp-fill {
  height: 100%;
  background: linear-gradient(90deg, #22d3ee, #38bdf8, #0ea5e9);
  box-shadow: 0 0 12px #38bdf8;
  transition: width 0.5s ease;
}

/* ====== CHIP ====== */
.chip{
  display:inline-block;
  margin-top:10px;
  padding:6px 10px;
  font-size:12px;
  letter-spacing:1px;
  color:#a5f3fc;
  border:1px solid rgba(34,211,238,0.35);
  border-radius:999px;
  background: rgba(2,6,23,0.55);
  box-shadow: 0 0 14px rgba(34,211,238,0.15);
}

/* ====== RANK CARD GAME FX ====== */
.rank-bg {
  position: absolute;
  inset: -40px;
  background:
    radial-gradient(circle at 20% 30%, rgba(34,211,238,0.25), transparent 55%),
    radial-gradient(circle at 80% 70%, rgba(56,189,248,0.18), transparent 60%),
    radial-gradient(circle at 50% 50%, rgba(14,165,233,0.12), transparent 65%);
  filter: blur(12px);
  animation: bgFloat 8s ease-in-out infinite;
  z-index: 0;
}

@keyframes bgFloat {
  0% { transform: translate(0,0) scale(1); }
  50% { transform: translate(12px,-8px) scale(1.03); }
  100% { transform: translate(0,0) scale(1); }
}

.rank-noise {
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='260' height='260'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='260' height='260' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
  opacity: 0.12;
  mix-blend-mode: overlay;
  z-index: 1;
}

.rank-card::after {
  content: "";
  position: absolute;
  inset: -2px;
  border-radius: 18px;
  padding: 2px;
  background: linear-gradient(120deg, rgba(34,211,238,0.9), rgba(56,189,248,0.0), rgba(34,211,238,0.7));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.55;
  filter: drop-shadow(0 0 18px rgba(34,211,238,0.35));
  animation: edgePulse 3.2s ease-in-out infinite;
  z-index: 2;
}

@keyframes edgePulse {
  0%, 100% { opacity: 0.35; }
  50% { opacity: 0.75; }
}

/* make inner content above effects */
.rank-icon, .rank-info { position: relative; z-index: 3; }

.rank-icon::before {
  content: "";
  position: absolute;
  inset: -18px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(34,211,238,0.35), transparent 65%);
  filter: blur(10px);
  opacity: 0.9;
}

.rank-icon::after {
  content: "";
  position: absolute;
  inset: 10px;
  border-radius: 50%;
  background: radial-gradient(circle at 25% 25%, rgba(255,255,255,0.35), transparent 55%);
  opacity: 0.7;
}
  * ===========================
   CINEMATIC V2 (NO-LAG)
   =========================== */

/* keep in DOM; animate opacity/transform only */
.cinematic{
  position: fixed;
  inset: 0;
  z-index: 9999;
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease;
  will-change: opacity;
}

.cinematic.is-open{
  opacity: 1;
  pointer-events: auto;
}

/* backdrop: avoid heavy backdrop-filter */
.cinematic-bg{
  position:absolute;
  inset:0;
  background: rgba(0,0,0,0.78);
}

/* FX layer via pseudo elements (cheap) */
.cinematic-bg::before{
  content:"";
  position:absolute;
  inset:-30%;
  background:
    radial-gradient(circle at 50% 40%,
      color-mix(in srgb, var(--cin-accent, #22d3ee) 35%, transparent) 0%,
      transparent 62%
    );
  opacity: var(--cin-burst, 0.25);
  transform: scale(0.95);
  filter: blur(1px);
}

.cinematic-bg::after{
  content:"";
  position:absolute;
  inset:0;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255,255,255,0.035) 0px,
    rgba(255,255,255,0.035) 1px,
    rgba(0,0,0,0) 4px,
    rgba(0,0,0,0) 8px
  );
  opacity: 0.08;
  animation: cinScan 1.6s linear infinite;
  pointer-events:none;
}

@keyframes cinScan{
  0%{ transform: translateY(-6%); }
  100%{ transform: translateY(6%); }
}

/* card */
.cinematic-card{
  position:relative;
  width: min(820px, 92vw);
  border-radius: 22px;
  background: linear-gradient(135deg, rgba(2,6,23,0.92), rgba(15,23,42,0.90));
  border: 1px solid rgba(255,255,255,0.08);
  padding: 28px 24px 22px;
  overflow:hidden;

  /* GPU-friendly entry */
  transform: translate3d(0, 18px, 0) scale(0.98);
  opacity: 0;
  will-change: transform, opacity;
}

/* open animations */
.cinematic.is-open .cinematic-card{
  animation: cinCardIn 420ms cubic-bezier(.2,.9,.2,1) forwards;
}
@keyframes cinCardIn{
  to { transform: translate3d(0,0,0) scale(1); opacity: 1; }
}

/* modes */
.cinematic[data-mode="up"]{ --cin-burst: 0.32; }
.cinematic[data-mode="down"]{ --cin-burst: 0.22; }

.cinematic[data-mode="up"].is-open .cinematic-card{
  animation: cinUp 520ms cubic-bezier(.2,.9,.2,1) forwards;
}
@keyframes cinUp{
  0%{ transform: translate3d(0, 22px, 0) scale(0.96); opacity: 0; }
  55%{ transform: translate3d(0, -2px, 0) scale(1.02); opacity: 1; }
  100%{ transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
}

.cinematic[data-mode="down"].is-open .cinematic-card{
  animation: cinDown 520ms cubic-bezier(.2,.9,.2,1) forwards;
}
@keyframes cinDown{
  0%{ transform: translate3d(0, -10px, 0) scale(0.98); opacity: 0; }
  55%{ transform: translate3d(0, 10px, 0) scale(1.00); opacity: 1; }
  100%{ transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
}

/* badge */
.cin-badgeWrap{
  margin-top: 14px;
  display:flex;
  justify-content:center;
}

.cin-badgeImg{
  width: 160px;
  height: 160px;
  object-fit: contain;
  transform: translate3d(0,0,0);
  will-change: transform, opacity;
  filter: drop-shadow(0 0 18px color-mix(in srgb, var(--cin-accent, #22d3ee) 35%, transparent));
  opacity: 0;
}

.cinematic.is-open .cin-badgeImg{
  animation: cinBadgePop 520ms cubic-bezier(.2,.9,.2,1) 60ms forwards;
}

@keyframes cinBadgePop{
  0%{ opacity: 0; transform: translate3d(0, 10px, 0) scale(0.92); }
  60%{ opacity: 1; transform: translate3d(0, -2px, 0) scale(1.05); }
  100%{ opacity: 1; transform: translate3d(0, 0, 0) scale(1); }
}

/* close (fade out) */
.cinematic.is-closing{
  opacity: 0;
  pointer-events: none;
}

/* reduce motion */
@media (prefers-reduced-motion: reduce){
  .cinematic-bg::after{ animation: none !important; }
  .cinematic-card, .cin-badgeImg{ animation: none !important; opacity: 1 !important; transform: none !important; }
}
  
</style>
  <!-- ===== END OF CSS ===== -->
</head>
  
<!-- ============================= -->
<!-- ===== APPLICATION UI ======= -->
<!-- ============================= -->
<body>

<!-- NAVIGATION -->
<div class="navbar">
  <button class="nav-btn active" onclick="showTab('dashboard', this)">DASHBOARD</button>
  <button class="nav-btn" onclick="showTab('rank', this)">RANK</button>
  <button class="nav-btn" onclick="showTab('history', this)">MATCH HISTORY</button>
  <button class="nav-btn" onclick="showTab('add', this)">ADD MATCH</button>
</div>

<!-- DASHBOARD -->
<div id="dashboard" class="section active">
  <h1>Player Dashboard</h1>
  <p>Overview of your ranked progress.</p>

  <div class="panel">
    <p>üîπ Current RP: <strong>1250</strong></p>
    <p>üîπ Current Rank: <strong>PHANTOM II</strong></p>
    <p>üîπ Win Streak: <strong>3</strong></p>
  </div>
  <div class="actions" style="margin-top:14px;">
  <button class="btn ghost" type="button" onclick="startNewSeason()">Start New Season</button>
  <div class="hint">Starts a new season (RR resets). Past seasons remain available.</div>
</div>
</div>

<!-- RANK -->
<div id="rank" class="section">
  <h1>Competitive Rank</h1>
  <p>Your current competitive standing.</p>

  <!-- RANK CARD -->
  <div class="rank-card">
    <div class="rank-bg"></div>
    <div class="rank-noise"></div>

    <div class="rank-icon" id="rankCardIcon">
  <img id="rankBadgeImg" src="" alt="Rank badge">
  <div class="rank-glow"></div>
    </div>

    <div class="rank-info">
      <h2 id="rankCardTitle">PHANTOM II</h2>
      <span class="rank-rp" id="rankCardRP">RP: 1250 / 1500</span>
      <div class="chip" id="rankCardChip">NEON ASCENSION</div>

      <div class="rp-bar">
        <div class="rp-fill" id="rankCardFill" style="width: 83%;"></div>
      </div>
    </div>
  </div>

  <!-- RANK LADDER (OUTSIDE rank-card) -->
  <div class="ladder">
    <div class="ladder-head">
      <h3>Rank Ladder</h3>
      <span class="ladder-note">Locked ranks are dimmed. Current rank is highlighted.</span>
    </div>

    <div class="ladder-list">
      <div class="ladder-item unlocked">
        <div class="badge b-outcast"></div>
        <div class="meta">
          <div class="name">OUTCAST</div>
          <div class="desc">Chaos-born survivors.</div>
        </div>
      </div>

      <div class="ladder-item unlocked">
        <div class="badge b-vanguard"></div>
        <div class="meta">
          <div class="name">VANGUARD</div>
          <div class="desc">Rising force.</div>
        </div>
      </div>

      <div class="ladder-item unlocked">
        <div class="badge b-sentinel"></div>
        <div class="meta">
          <div class="name">SENTINEL</div>
          <div class="desc">Control & discipline.</div>
        </div>
      </div>

      <div class="ladder-item unlocked current">
        <div class="badge b-phantom"></div>
        <div class="meta">
          <div class="name">PHANTOM</div>
          <div class="desc">Precision mastery.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-warlord"></div>
        <div class="meta">
          <div class="name">WARLORD</div>
          <div class="desc">Aggressive dominance.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-archon"></div>
        <div class="meta">
          <div class="name">ARCHON</div>
          <div class="desc">Authority.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-overseer"></div>
        <div class="meta">
          <div class="name">OVERSEER</div>
          <div class="desc">Vision & tactics.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-ascendant"></div>
        <div class="meta">
          <div class="name">ASCENDANT</div>
          <div class="desc">Transcendence.</div>
        </div>
      </div>

      <div class="ladder-item locked">
        <div class="badge b-paragon"></div>
        <div class="meta">
          <div class="name">PARAGON</div>
          <div class="desc">Elite standard.</div>
        </div>
      </div>

      <div class="ladder-item locked nexus">
        <div class="badge b-nexus"></div>
        <div class="meta">
          <div class="name">NEXUS</div>
          <div class="desc">Absolute peak.</div>
        </div>
      </div>
    </div>
  </div>
</div>

  
<!-- ADD MATCH -->
<div id="add" class="section">
  <h1>Add Match</h1>
  <p>Enter your match results. Everything updates automatically.</p>

  <div class="panel form">
    <div class="grid">
      <label>üèÜ Place (1‚Äì25)
        <input id="inPlace" type="number" min="1" max="25" value="10">
      </label>

      <label>üî´ Kills
        <input id="inKills" type="number" min="0" value="0">
      </label>

      <label>ü§ù Assists
        <input id="inAssists" type="number" min="0" value="0">
      </label>

      <label>üíÄ Deaths
        <input id="inDeaths" type="number" min="0" value="1">
      </label>
    </div>

    <div class="toggles">
      <label class="toggle">
        <input id="inMVP" type="checkbox">
        <span>‚≠ê MVP</span>
      </label>

      <label class="toggle">
        <input id="inLeft" type="checkbox">
        <span>‚ö† Teammate Left</span>
      </label>
    </div>

    <div class="actions">
      <button type="button" class="btn" onclick="submitMatch()">Submit Match</button>
      <button class="btn" onclick="undoLastMatch()">Undo Last Match</button>
      <button class="btn ghost" onclick="resetMatches()">Reset All Data</button>
      <div class="hint">Data is stored locally in your browser.</div>
    </div>
    <div class="panel" style="margin-top:16px;">
  <h3 style="margin-bottom:10px; letter-spacing:.6px;">Export / Import</h3>
  <p style="color:#9ca3af; font-size:12px; margin-bottom:10px;">
    Backup your matches as JSON, or import them on another device.
  </p>

  <textarea id="ioBox" rows="8" style="
    width:100%;
    resize:vertical;
    padding:12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.08);
    background:rgba(2,6,23,0.55);
    color:#e5e7eb;
    outline:none;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    font-size:12px;
    line-height:1.4;
  " placeholder="Paste JSON here (Import) or click Export to generate..."></textarea>

  <div class="actions" style="margin-top:10px;">
    <button class="btn" onclick="exportData()">Export JSON</button>
    <button class="btn" onclick="importData()">Import JSON</button>
    <button class="btn ghost" onclick="clearIO()">Clear Box</button>
    <button class="btn ghost" onclick="restoreBackup()">Restore Backup</button>
  </div>

  <div class="hint">Tip: Export copies JSON to clipboard automatically.</div>
</div>
  </div>
</div>

<!-- HISTORY -->
<div id="history" class="section">
  <h1>Match History</h1>
  <p>Your recent ranked matches and RP changes.</p>

  <div class="history-top">
    <div class="mini-card">
      <div class="mini-label">Win Streak</div>
      <div class="mini-value" id="streakValue">0</div>
    </div>
    <div class="mini-card">
      <div class="mini-label">Best Match</div>
      <div class="mini-value" id="bestValue">+0</div>
    </div>
    <div class="mini-card">
      <div class="mini-label">Worst Match</div>
      <div class="mini-value" id="worstValue">0</div>
    </div>
    <div class="season-summary" id="seasonSummary"></div>
  </div>

  <div class="history-controls">
  <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
    <label style="font-size:12px; color:#9ca3af;">Season:</label>
    <select id="seasonSelect" class="season-select"></select>
    <span id="readOnlyBadge" class="ro-badge" style="display:none;">READ ONLY</span>
    <button class="btn" id="toggleHistoryBtn" type="button">Show all</button>
    <button class="btn" type="button" onclick="renameSeason()">Rename</button>
    <button class="btn" type="button" onclick="renumberSeasonIds()">Fix IDs</button>
    <button class="btn ghost" type="button" onclick="deleteSeason()">Delete</button>
  </div>
  <div class="hint" id="historyHint">Showing last 20 matches</div>
</div>

<div class="match-list" id="matchList"></div>
</div>

<!-- CINEMATIC OVERLAY -->
<div id="cinematic" class="cinematic hidden">
  <div class="cinematic-bg"></div>
  <div class="cin-particles" id="cinParticles"></div>
 
  <div class="cin-wrap">
  <div class="cinematic-card">
    <div class="cinematic-title" id="cinTitle">RANK PROMOTED</div>
    <div class="cinematic-sub" id="cinSub">SENTINEL II ‚Üí PHANTOM III</div>
    <div class="cin-badgeWrap">
  <img id="cinBadgeImg" class="cin-badgeImg" src="" alt="Rank badge">
</div>

    <div class="cin-hint">Click or press ESC</div>
   </div>
  </div>
</div>
  
<!-- ============================= -->
<!-- ===== APPLICATION LOGIC ===== -->
<!-- ===== JAVASCRIPT (JS) ======= -->
<!-- ============================= -->
<script>
  function preloadRankBadges() {
  for (var i = 0; i < rankTiers.length; i++) {
    var img = new Image();
    img.src = "assets/ranks/" + String(rankTiers[i].name).toLowerCase() + ".webp";
  }
}
  
/* ===== NAV ===== */
function showTab(tabId, btn) {
  var sections = document.querySelectorAll(".section");
  for (var i = 0; i < sections.length; i++) sections[i].classList.remove("active");

  var buttons = document.querySelectorAll(".nav-btn");
  for (var j = 0; j < buttons.length; j++) buttons[j].classList.remove("active");

  var target = document.getElementById(tabId);
  if (target) target.classList.add("active");
  // Lock RP: when going to ADD MATCH, always switch viewing to ACTIVE season
  if (tabId === "add") {
    ensureSeasonSystem();
    var activeId = getActiveSeasonId();
    if (activeId) setSelectedSeasonId(activeId);
  }
  if (btn) btn.classList.add("active");
}

/* ===== STORAGE ===== */
var STORAGE_KEY = "bf6_ranked_matches_v1";
  var BACKUP_KEY = "bf6_backup_v1";

function makeBackup(reason) {
  var payload = {
    version: 1,
    reason: reason || "manual",
    createdAt: Date.now(),
    seasons: loadSeasons(),
    activeSeasonId: getActiveSeasonId(),
    selectedSeasonId: getSelectedSeasonId(),
    matches: loadMatches()
  };
  localStorage.setItem(BACKUP_KEY, JSON.stringify(payload));
}

function restoreBackup() {
  var raw = localStorage.getItem(BACKUP_KEY);
  if (!raw) {
    alert("No backup found.");
    return;
  }

  var payload;
  try {
    payload = JSON.parse(raw);
  } catch (e) {
    alert("Backup is corrupted.");
    return;
  }

  if (!payload || !Array.isArray(payload.matches) || !Array.isArray(payload.seasons)) {
    alert("Backup format invalid.");
    return;
  }

  if (!confirm("Restore backup? This will replace current data.")) return;

  saveMatches(payload.matches);
  saveSeasons(payload.seasons);

  setActiveSeasonId(payload.activeSeasonId || (payload.seasons[0] && payload.seasons[0].id) || "S1");
  setSelectedSeasonId(payload.selectedSeasonId || getActiveSeasonId());

  lastRankState = null;
  renderHistoryFromStorage();

  alert("Backup restored.");
}
var SEASONS_KEY = "bf6_seasons_v1";
var ACTIVE_SEASON_KEY = "bf6_active_season_v1";
var SELECTED_SEASON_KEY = "bf6_selected_season_v1"; // for UI viewing

function loadSeasons() {
  try {
    var raw = localStorage.getItem(SEASONS_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    return [];
  }
}

function saveSeasons(seasons) {
  localStorage.setItem(SEASONS_KEY, JSON.stringify(seasons));
}

function getActiveSeasonId() {
  return localStorage.getItem(ACTIVE_SEASON_KEY);
}

function setActiveSeasonId(id) {
  localStorage.setItem(ACTIVE_SEASON_KEY, id);
}

function getSelectedSeasonId() {
  // Selected season for viewing; default to active
  var v = localStorage.getItem(SELECTED_SEASON_KEY);
  return v ? v : getActiveSeasonId();
}

function setSelectedSeasonId(id) {
  localStorage.setItem(SELECTED_SEASON_KEY, id);
}

function ensureSeasonSystem() {
  var seasons = loadSeasons();
  // Backfill season name for legacy seasons
  var changed = false;
  for (var i = 0; i < seasons.length; i++) {
    if (!seasons[i].name) {
      seasons[i].name = seasons[i].id; // default name
      changed = true;
    }
  }
  if (changed) saveSeasons(seasons);
  var active = getActiveSeasonId();

  if (!seasons || seasons.length === 0 || !active) {
    // Create first season
    var id = "S1";
    var season = {
      id: id,
      startAt: Date.now(),
      endAt: null,
      finalRR: null,
      finalRankLabel: null,
      stats: null
    };
    saveSeasons([season]);
    setActiveSeasonId(id);
    setSelectedSeasonId(id);
    return;
  }

  // If selected missing, set to active
  var selected = getSelectedSeasonId();
  if (!selected) setSelectedSeasonId(active);
}
  function computeSeasonStats(matches) {
  var count = matches.length;
  if (count === 0) {
    return {
      matchesCount: 0,
      bestRR: 0,
      worstRR: 0,
      avgRR: 0,
      top1Count: 0,
      top3Count: 0,
      top7Count: 0,
      mvpCount: 0,
      leftCount: 0
    };
  }

  var best = -Infinity;
  var worst = Infinity;
  var sum = 0;

  var top1 = 0, top3 = 0, top7 = 0, mvpCount = 0, leftCount = 0;

  for (var i = 0; i < matches.length; i++) {
    var m = matches[i];
    var rr = Number(m.rp || 0);
    sum += rr;
    if (rr > best) best = rr;
    if (rr < worst) worst = rr;

    var p = Number(m.place || 99);
    if (p === 1) top1++;
    if (p <= 3) top3++;
    if (p <= 7) top7++;

    if (m.mvp) mvpCount++;
    if (m.left) leftCount++;
  }

  return {
    matchesCount: count,
    bestRR: best,
    worstRR: worst,
    avgRR: Math.round(sum / count),
    top1Count: top1,
    top3Count: top3,
    top7Count: top7,
    mvpCount: mvpCount,
    leftCount: leftCount
  };
}
  
var HISTORY_LIMIT_KEY = "bf6_history_limit_v1";

function loadMatches() {
  try {
    var raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    return [];
  }
}

function saveMatches(matches) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(matches));
}
  
  
/* ===== RANK SETTINGS (Valorant-like divisions) ===== */
var START_RP = 0;
var MIN_RP = 0;
var DIV_RR = 100;
var DIVS_PER_TIER = 3;

/*
IMPORTANT:
To have exactly 3 divisions per tier (III/II/I), each tier should span 300 RR.
So tier mins are spaced by 300.
This also makes ranking progression consistent and hard.
*/
var rankTiers = [
  { name: "OUTCAST",  color: "#ffb86b", min: 0   },
  { name: "VANGUARD", color: "#22d3ee", min: 300 },
  { name: "SENTINEL", color: "#38bdf8", min: 600 },
  { name: "PHANTOM",  color: "#a78bfa", min: 900 },
  { name: "WARLORD",  color: "#fb7185", min: 1200 },
  { name: "ARCHON",   color: "#fbbf24", min: 1500 },
  { name: "OVERSEER", color: "#2dd4bf", min: 1800 },
  { name: "ASCENDANT",color: "#60a5fa", min: 2100 },
  { name: "PARAGON",  color: "#e5e7eb", min: 2400 },
  { name: "NEXUS",    color: "#ff3b3b", min: 2700 }
];

// cinematic tracking (tier + division)
var lastRankState = null; // { tierIndex, divIndex, label }

/* ===== RANK CALC ===== */
function getRank(totalRP) {
  // find tier index
  var tierIndex = 0;
  for (var i = 0; i < rankTiers.length; i++) {
    if (totalRP >= rankTiers[i].min) tierIndex = i;
  }

  var tier = rankTiers[tierIndex];

  // NEXUS special case
  if (tier.name === "NEXUS") {
    return {
      label: "NEXUS",
      tierName: "NEXUS",
      tierIndex: tierIndex,
      div: null,
      divIndex: null,
      color: tier.color,
      rr: 100,
      nextMin: null
    };
  }

  var nextTier = rankTiers[tierIndex + 1];

  // RR inside this tier
  var rrInTier = totalRP - tier.min;
  if (rrInTier < 0) rrInTier = 0;

  // Division index (0..2) based on 100 RR chunks
  var divIndex = Math.floor(rrInTier / DIV_RR);
  if (divIndex < 0) divIndex = 0;
  if (divIndex > (DIVS_PER_TIER - 1)) divIndex = (DIVS_PER_TIER - 1);

  // RR progress inside current division (0..99)
  var rr = rrInTier - (divIndex * DIV_RR);
  if (rr < 0) rr = 0;
  if (rr > (DIV_RR - 1)) rr = (DIV_RR - 1);

  // Division label mapping: 0->III, 1->II, 2->I
  var div = (divIndex === 0) ? "III" : (divIndex === 1 ? "II" : "I");

  // Label
  var label = tier.name + " " + div;

  // Next threshold shown on UI
  var nextMin = null;
  if (divIndex === (DIVS_PER_TIER - 1)) nextMin = nextTier ? nextTier.min : null;
  else nextMin = tier.min + ((divIndex + 1) * DIV_RR);

  return {
    label: label,
    tierName: tier.name,
    tierIndex: tierIndex,
    div: div,
    divIndex: divIndex,
    color: tier.color,
    rr: rr, // 0..99
    nextMin: nextMin
  };
}

/* ===== BR RR FORMULA (hard to climb) ===== */
function calcRPBreakdown(m) {
  var place = Math.min(25, Math.max(1, Number(m.place || 25)));
  var kills = Math.max(0, Number(m.kills || 0));
  var assists = Math.max(0, Number(m.assists || 0));
  var deaths = Math.max(0, Number(m.deaths || 0));
  var mvp = !!m.mvp;
  var left = !!m.left;

  var contrib = kills + assists;

  // Contribution tiers
  var isLow = contrib < 5;
  var isNormal = contrib >= 5;
  var isHigh = (kills >= 10) || (contrib >= 20);

  // Placement base
  var placementBase = 0;
  if (place === 1) placementBase = 26;
  else if (place === 2) placementBase = 22;
  else if (place === 3) placementBase = 20;
  else if (place === 4) placementBase = 17;
  else if (place === 5) placementBase = 15;
  else if (place === 6) placementBase = 13;
  else if (place === 7) placementBase = 11;
  else if (place >= 8 && place <= 11) placementBase = 0;
  else if (place >= 12 && place <= 15) placementBase = -2;
  else if (place === 16) placementBase = -4;
  else if (place === 17) placementBase = -6;
  else if (place === 18) placementBase = -8;
  else if (place === 19) placementBase = -10;
  else if (place === 20) placementBase = -12;
  else if (place === 21) placementBase = -14;
  else if (place === 22) placementBase = -16;
  else if (place === 23) placementBase = -18;
  else if (place === 24) placementBase = -20;
  else placementBase = -22;

  // Placement modifier by contribution
  var placementMod = 0;
  if (place <= 7) {
    if (isHigh) placementMod = 2;
    else if (isNormal) placementMod = 1;
    else placementMod = 0;
  } else if (place >= 8 && place <= 11) {
    if (isHigh) placementMod = 3;
    else if (isNormal) placementMod = 2;
    else placementMod = 0;
  } else if (place >= 12 && place <= 15) {
    if (isHigh) placementMod = 3;        // -2 +3 = +1
    else if (isNormal) placementMod = 2;  // -2 +2 = 0
    else placementMod = -2;              // -2 -2 = -4
  } else {
    placementMod = 0; // place > 15: no mod
  }

  var placementScore = placementBase + placementMod;

  // Combat score (normalized & capped)
  var killScore = 0;
  var k1 = Math.min(kills, 5);
  var k2 = Math.min(Math.max(kills - 5, 0), 5);
  killScore += k1 * 2;
  killScore += k2 * 1;

  var assistScore = 0;
  var a1 = Math.min(assists, 5);
  var a2 = Math.min(Math.max(assists - 5, 0), 5);
  assistScore += a1 * 1;
  assistScore += a2 * 0.5;

  var deathScore = -2 * deaths;
  if (deathScore < -10) deathScore = -10;

  var combatScore = killScore + assistScore + deathScore;
  if (combatScore > 14) combatScore = 14;

  var mvpBonus = mvp ? 3 : 0;

  var leftBonus = 0;
  if (left) {
    if (place === 1) leftBonus = 10;
    else if (place <= 3) leftBonus = 7;
    else if (place <= 7) leftBonus = 4;
  }

  var total = placementScore + combatScore + mvpBonus + leftBonus;

  // Clamp final RR per match
  if (total > 32) total = 32;
  if (total < -25) total = -25;

  // Invalid-ish protection
  if (left && place > 15 && total < -8) total = -8;

  total = Math.round(total);

  return {
    place: place,
    contrib: contrib,
    placementBase: placementBase,
    placementMod: placementMod,
    placementScore: placementScore,
    killScore: killScore,
    assistScore: assistScore,
    deathScore: deathScore,
    combatScore: combatScore,
    mvpBonus: mvpBonus,
    leftBonus: leftBonus,
    total: total
  };
}

/* ===== CINEMATIC ===== */
function hideCinematic() {
  var el = document.getElementById("cinematic");
  if (el) el.classList.add("hidden");
}

function getTierNameFromLabel(label) {
  return String(label || "").trim().split(" ")[0].toUpperCase();
}

function getTierKeyFromLabel(label) {
  return getTierNameFromLabel(label).toLowerCase();
}

function showCinematic(fromRank, toRank, isPromotion, changeType) {
  // changeType: "division" | "tier"
  var el = document.getElementById("cinematic");
  var title = document.getElementById("cinTitle");
  var sub = document.getElementById("cinSub");
  var badge = document.getElementById("cinBadgeImg");

  if (!el || !title || !sub) return;

  var mode = isPromotion ? "up" : "down";
  el.dataset.mode = mode;

  // accent from toTier
  var toTier = getTierNameFromLabel(toRank);
  var accent = "#22d3ee";
  for (var i = 0; i < rankTiers.length; i++) {
    if (rankTiers[i].name === toTier) accent = rankTiers[i].color;
  }
  el.style.setProperty("--cin-accent", accent);

  // title text differs by change type
  if (changeType === "tier") title.textContent = isPromotion ? "TIER UP" : "TIER DOWN";
  else title.textContent = isPromotion ? "DIVISION UP" : "DIVISION DOWN";

  sub.textContent = String(fromRank) + " ‚Üí " + String(toRank);

  // badge image
  if (badge) {
    badge.src = "assets/ranks/" + getTierKeyFromLabel(toRank) + ".webp";
  }

  // cancel previous timers
  if (window.__cinT) clearTimeout(window.__cinT);

  // open without layout thrash: use requestAnimationFrame to trigger animations
  el.classList.remove("hidden"); // if you still have old hidden class
  el.classList.remove("is-closing");
  el.classList.add("is-open");

  window.__cinT = setTimeout(function () {
    el.classList.add("is-closing");
    el.classList.remove("is-open");
  }, (changeType === "tier" ? 2600 : 1600));
}

document.addEventListener("keydown", function (e) {
  if (e.key === "Escape") hideCinematic();
});

var cinRoot = document.getElementById("cinematic");
if (cinRoot) {
  cinRoot.addEventListener("click", function (e) {
    var t = e.target;
    var isBg = t && t.classList && t.classList.contains("cinematic-bg");
    var isRoot = t === cinRoot;
    if (isBg || isRoot) hideCinematic();
  });
}

/* ===== LADDER UI ===== */
function updateLadderUI(currentTierIndex) {
  var items = document.querySelectorAll(".ladder-list .ladder-item");

  for (var i = 0; i < items.length; i++) {
    var item = items[i];

    // State classes
    item.classList.remove("locked", "unlocked", "current");
    if (i < currentTierIndex) item.classList.add("unlocked");
    else if (i === currentTierIndex) item.classList.add("unlocked", "current");
    else item.classList.add("locked");

    // Badge image from rankTiers (reliable)
    var badgeEl = item.querySelector(".badge");
    if (badgeEl && rankTiers[i] && rankTiers[i].name) {
      var tierKey = String(rankTiers[i].name).toLowerCase();

      // Force override ANY existing gradient backgrounds
      badgeEl.style.background = 'url("assets/ranks/' + tierKey + '.webp") center / contain no-repeat';
    }
  }
}

/* ===== UI UPDATES ===== */
function updateRankUI(matchesAll) {
  // Backfill breakdown for old matches
  for (var bi = 0; bi < matchesAll.length; bi++) {
    if (!matchesAll[bi].breakdown) {
      matchesAll[bi].breakdown = calcRPBreakdown(matchesAll[bi]);
      matchesAll[bi].rp = matchesAll[bi].breakdown.total;
    }
  }

  var sum = 0;
  for (var i = 0; i < matchesAll.length; i++) sum += Number(matchesAll[i].rp || 0);

  var totalRP = START_RP + sum;
  if (totalRP < MIN_RP) totalRP = MIN_RP;

  var rank = getRank(totalRP);

  // Rank card elements (IDs preferred)
  var rankTitle = document.getElementById("rankCardTitle") || document.querySelector("#rank .rank-info h2");
  var rankRP = document.getElementById("rankCardRP") || document.querySelector("#rank .rank-rp");
  var rpFill = document.getElementById("rankCardFill") || document.querySelector("#rank .rp-fill");
  var chip = document.getElementById("rankCardChip");
  var icon = document.getElementById("rankCardIcon");

  if (rankTitle) rankTitle.textContent = rank.label;
  // Rank badge image
const badgeImg = document.getElementById("rankBadgeImg");
if (badgeImg && rank.tierName) {
  const tierKey = rank.tierName.toLowerCase();
  badgeImg.src = "assets/ranks/" + tierKey + ".webp";
}

  if (rankRP) {
    if (rank.tierName === "NEXUS") rankRP.textContent = "RR: " + totalRP + " (MAX)";
    else rankRP.textContent = "RR: " + totalRP + " / " + rank.nextMin;
  }

  if (rpFill) {
    var pct = Math.round((rank.rr / (DIV_RR - 1)) * 100);
    rpFill.style.width = String(pct) + "%";
  }

  if (chip) {
    chip.textContent = rank.tierName === "NEXUS" ? "ABSOLUTE PEAK" : ("TIER: " + rank.tierName);
  }
  if (icon) {
    icon.style.setProperty("--rank-accent", rank.color);
  }

  updateLadderUI(rank.tierIndex);

  // Dashboard
  var dash = document.querySelector("#dashboard .panel");
  if (dash) {
    dash.innerHTML =
      "<p>üîπ Current RR: <strong>" + totalRP + "</strong></p>" +
      "<p>üîπ Current Rank: <strong>" + rank.label + "</strong></p>" +
      "<p>üîπ Matches: <strong>" + matchesAll.length + "</strong></p>";
  }

  // Cinematic trigger (tier + division)
  var currentState = { tierIndex: rank.tierIndex, divIndex: rank.divIndex, label: rank.label };

  if (lastRankState === null) {
    lastRankState = currentState;
  } else {
    var tierChanged = currentState.tierIndex !== lastRankState.tierIndex;
    var divChanged = currentState.divIndex !== lastRankState.divIndex;

    if (tierChanged) {
      var promotedTier = currentState.tierIndex > lastRankState.tierIndex;
      showCinematic(lastRankState.label, currentState.label, promotedTier, "tier");
      lastRankState = currentState;
    } else if (divChanged) {
      var a = (currentState.divIndex === null || currentState.divIndex === undefined) ? 0 : currentState.divIndex;
      var b = (lastRankState.divIndex === null || lastRankState.divIndex === undefined) ? 0 : lastRankState.divIndex;
      var promotedDiv = a > b;
      showCinematic(lastRankState.label, currentState.label, promotedDiv, "division");
      lastRankState = currentState;
    }
  }
}
function getHistoryLimit() {
  // "20" or "all"
  var v = localStorage.getItem(HISTORY_LIMIT_KEY);
  return v ? v : "20";
}

function setHistoryLimit(val) {
  localStorage.setItem(HISTORY_LIMIT_KEY, val);
}
  
function renderHistoryFromStorage() {
  var matchesAll = loadMatches();
  // Backfill matchId for legacy matches
var changedId = false;
for (var mi = 0; mi < matchesAll.length; mi++) {
  if (!matchesAll[mi].matchId) {
    matchesAll[mi].matchId = genMatchId(matchesAll[mi].ts || Date.now());
    changedId = true;
  }
}
if (changedId) saveMatches(matchesAll);
  
  ensureSeasonSystem();
  
  

var activeSeasonId = getActiveSeasonId();
var selectedSeasonId = getSelectedSeasonId();

// Build two views: active (for Rank) and selected (for History)
var activeMatchesAll = [];
var selectedMatchesAll = [];

for (var fi = 0; fi < matchesAll.length; fi++) {
  // If old match has no seasonId, assign to active season (legacy)
  if (!matchesAll[fi].seasonId) matchesAll[fi].seasonId = activeSeasonId;

  if (matchesAll[fi].seasonId === activeSeasonId) activeMatchesAll.push(matchesAll[fi]);
  if (matchesAll[fi].seasonId === selectedSeasonId) selectedMatchesAll.push(matchesAll[fi]);
}

// Persist possible legacy patch
saveMatches(matchesAll);

// From now on:
// - use activeMatchesAll for Rank UI
// - use selectedMatchesAll for History list & stats
  
  // Build season dropdown
var seasons = loadSeasons();
var activeId = getActiveSeasonId();
var select = document.getElementById("seasonSelect");

if (select) {
  select.innerHTML = "";
  for (var si = seasons.length - 1; si >= 0; si--) {
    var s = seasons[si];
    var opt = document.createElement("option");
    var label = (s.name ? s.name : s.id);
    label += " [" + s.id + "]";

    if (s.id === activeId) label += " (Active)";
    if (s.finalRankLabel) label += " ‚Ä¢ " + s.finalRankLabel;

    opt.value = s.id;
    opt.textContent = label;

    select.appendChild(opt);
  }

  select.value = selectedSeasonId || activeId;
}
  // Read-only mode indicator (History viewing non-active season)
var ro = document.getElementById("readOnlyBadge");
var isReadOnly = (selectedSeasonId !== activeSeasonId);
if (ro) ro.style.display = isReadOnly ? "inline-block" : "none";

// Disable destructive season actions when read-only (optional UX)
var renameBtn = document.querySelector('button[onclick="renameSeason()"]');
var deleteBtn = document.querySelector('button[onclick="deleteSeason()"]');
if (renameBtn) renameBtn.disabled = false; // allow rename anytime (your choice)
if (deleteBtn) deleteBtn.disabled = false; // delete already has safety checks

// If you want to block rename/delete while viewing non-active season, uncomment:
// if (renameBtn) renameBtn.disabled = isReadOnly;
// if (deleteBtn) deleteBtn.disabled = isReadOnly;
  
  // Render season summary panel (selected season)
var summaryEl = document.getElementById("seasonSummary");
if (summaryEl) {
  var seasonsList = loadSeasons();
  var selectedMeta = null;
  for (var si = 0; si < seasonsList.length; si++) {
    if (seasonsList[si].id === selectedSeasonId) selectedMeta = seasonsList[si];
  }

  var isActive = (selectedSeasonId === activeSeasonId);

  // Compute current RR/rank for selected season (even if ended, for display consistency)
  var sumRR = 0;
  for (var mi = 0; mi < selectedMatchesAll.length; mi++) sumRR += Number(selectedMatchesAll[mi].rp || 0);
  var currentRR = START_RP + sumRR;
  if (currentRR < MIN_RP) currentRR = MIN_RP;
  var currentRank = getRank(currentRR);

  var stats = computeSeasonStats(selectedMatchesAll);

  var html = "";
  html += "<div class='row'><div class='k'>Season</div><div class='v'>" +
          selectedSeasonId + " " + (isActive ? "<span class='season-tag active'>Active</span>" : "<span class='season-tag'>Ended</span>") +
          "</div></div>";

  html += "<div class='row'><div class='k'>Current Rank</div><div class='v'>" + currentRank.label + "</div></div>";
  html += "<div class='row'><div class='k'>Current RR</div><div class='v'>" + currentRR + "</div></div>";

  if (selectedMeta && !isActive) {
    if (selectedMeta.finalRankLabel) {
      html += "<div class='row'><div class='k'>Final Rank</div><div class='v'>" + selectedMeta.finalRankLabel + "</div></div>";
    }
    if (selectedMeta.finalRR !== null && selectedMeta.finalRR !== undefined) {
      html += "<div class='row'><div class='k'>Final RR</div><div class='v'>" + selectedMeta.finalRR + "</div></div>";
    }
  }

  html += "<div class='row'><div class='k'>Matches</div><div class='v'>" + stats.matchesCount + "</div></div>";
  html += "<div class='row'><div class='k'>Avg RR / match</div><div class='v'>" + stats.avgRR + "</div></div>";
  html += "<div class='row'><div class='k'>Best / Worst</div><div class='v'>" + (stats.bestRR >= 0 ? "+" + stats.bestRR : stats.bestRR) +
          " / " + (stats.worstRR >= 0 ? "+" + stats.worstRR : stats.worstRR) + "</div></div>";
  html += "<div class='row'><div class='k'>Top1 / Top3 / Top7</div><div class='v'>" +
          stats.top1Count + " / " + stats.top3Count + " / " + stats.top7Count + "</div></div>";
  html += "<div class='row'><div class='k'>MVP</div><div class='v'>" + stats.mvpCount + "</div></div>";
  html += "<div class='row'><div class='k'>Teammate Left</div><div class='v'>" + stats.leftCount + "</div></div>";

  summaryEl.innerHTML = html;
}

  // Backfill + recalc rp with current formula
  var changed = false;
  for (var i = 0; i < matchesAll.length; i++) {
    matchesAll[i].breakdown = calcRPBreakdown(matchesAll[i]);
    matchesAll[i].rp = matchesAll[i].breakdown.total;
    changed = true;
  }
  if (changed) saveMatches(matchesAll);

  updateRankUI(activeMatchesAll);

  // Display list: newest first, last 20
  var matches = selectedMatchesAll.slice();
  matches.sort(function(a, b) { return Number(b.ts || 0) - Number(a.ts || 0); });

  var mode = getHistoryLimit(); // "20" or "all"
var MAX_MATCHES = (mode === "all") ? 0 : 20;

if (MAX_MATCHES > 0 && matches.length > MAX_MATCHES) matches = matches.slice(0, MAX_MATCHES);

// Update UI label/button
var toggleBtn = document.getElementById("toggleHistoryBtn");
var hint = document.getElementById("historyHint");
if (toggleBtn) toggleBtn.textContent = (mode === "all") ? "Show last 20" : "Show all";
if (hint) hint.textContent = (mode === "all") ? ("Showing all matches (" +selectedMatchesAll.length + ")") : "Showing last 20 matches";

  var list = document.getElementById("matchList");
  if (!list) return;
  list.innerHTML = "";

  var streakEl = document.getElementById("streakValue");
  var bestEl = document.getElementById("bestValue");
  var worstEl = document.getElementById("worstValue");

  if (selectedMatchesAll.length === 0) {
    var panel = document.createElement("div");
    panel.className = "panel";
    var p = document.createElement("p");
    p.innerHTML = 'No matches yet. Add your first match in <b>ADD MATCH</b>.';
    panel.appendChild(p);
    list.appendChild(panel);

    if (streakEl) streakEl.textContent = "0";
    if (bestEl) bestEl.textContent = "+0";
    if (worstEl) worstEl.textContent = "0";
    return;
  }

  // Best / worst across ALL matches
  var best = -Infinity;
  var worst = Infinity;
  for (var b = 0; b < selectedMatchesAll.length; b++) {
    var rp = Number(selectedMatchesAll[b].rp || 0);
    if (rp > best) best = rp;
    if (rp < worst) worst = rp;
  }
  if (bestEl) bestEl.textContent = best >= 0 ? ("+" + best) : String(best);
  if (worstEl) worstEl.textContent = String(worst);

  // Streak across ALL matches (place <= 3), newest backwards by ts
  var sortedAll = selectedMatchesAll.slice().sort(function(a, b) { return Number(b.ts || 0) - Number(a.ts || 0); });
  var streak = 0;
  for (var s = 0; s < sortedAll.length; s++) {
    if (Number(sortedAll[s].place || 99) <= 3) streak++;
    else break;
  }
  if (streakEl) streakEl.textContent = String(streak);

  // Render visible cards
  for (var idx = 0; idx < matches.length; idx++) {
    var m = matches[idx];

    var card = document.createElement("div");
    card.className = "match-card";
    if (m.rp === best) card.classList.add("best");
    if (m.rp === worst) card.classList.add("worst");

    var row = document.createElement("div");
    row.className = "match-row";

    var left = document.createElement("div");
    left.className = "left";

    var title = document.createElement("div");
    title.className = "title";

    var matchNum = document.createElement("span");
    matchNum.textContent = "Match #" + (idx + 1);
    title.appendChild(matchNum);

    var badges = document.createElement("div");
    badges.className = "badges";

    if (m.mvp) {
      var b1 = document.createElement("span");
      b1.className = "badge-pill badge-mvp";
      b1.textContent = "‚≠ê MVP";
      badges.appendChild(b1);
    }
    if (m.left) {
      var b2 = document.createElement("span");
      b2.className = "badge-pill badge-leave";
      b2.textContent = "‚ö† Teammate Left";
      badges.appendChild(b2);
    }
    title.appendChild(badges);

    var place = document.createElement("div");
    place.className = "place";
    place.innerHTML = "üèÜ Place: <strong>" + m.place + "</strong> / 25 teams";

    var kad = document.createElement("div");
    kad.className = "kad";
    kad.innerHTML =
      "üî´ K/A/D: <strong>" + m.kills + "</strong> / <strong>" + m.assists + "</strong> / <strong>" + m.deaths + "</strong>";

    left.appendChild(title);
    left.appendChild(place);
    var time = document.createElement("div");
    time.className = "kad";
    time.textContent = "üïí " + new Date(Number(m.ts || 0)).toLocaleString();
    left.appendChild(time);
    left.appendChild(kad);

    var rpDelta = document.createElement("div");
    rpDelta.className = "rpDelta " + (m.rp >= 0 ? "rpPlus" : "rpMinus");
    rpDelta.textContent = (m.rp >= 0 ? "+" + m.rp : String(m.rp)) + " RR";

    row.appendChild(left);
    row.appendChild(rpDelta);
    
    

    card.appendChild(row);
    list.appendChild(card);
  }
}
  
function clampInt(value, min, max, fallback) {
  var n = Number(value);
  if (!isFinite(n)) n = (fallback !== undefined) ? fallback : min;
  n = Math.floor(n);
  if (n < min) n = min;
  if (n > max) n = max;
  return n;
}
  function clampInt(value, min, max, fallback) {
  var n = Number(value);
  if (!isFinite(n)) n = (fallback !== undefined) ? fallback : min;
  n = Math.floor(n);
  if (n < min) n = min;
  if (n > max) n = max;
  return n;
}
  
/* ===== ACTIONS ===== */
function startNewSeason() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var activeId = getActiveSeasonId();

  // Compute final stats for active season
  var allMatches = loadMatches();
  var activeMatches = [];
  for (var i = 0; i < allMatches.length; i++) {
    if (allMatches[i].seasonId === activeId) activeMatches.push(allMatches[i]);
  }

  // Final RR for season = START_RP + sum(rr)
  var sum = 0;
  for (var j = 0; j < activeMatches.length; j++) sum += Number(activeMatches[j].rp || 0);
  var finalRR = START_RP + sum;
  if (finalRR < MIN_RP) finalRR = MIN_RP;

  var finalRank = getRank(finalRR);

  // Close current season
  for (var s = 0; s < seasons.length; s++) {
    if (seasons[s].id === activeId) {
      seasons[s].endAt = Date.now();
      seasons[s].finalRR = finalRR;
      seasons[s].finalRankLabel = finalRank.label;
      seasons[s].stats = computeSeasonStats(activeMatches);
    }
  }

  // Create next season id based on max existing S#
var maxNum = 0;
for (var x = 0; x < seasons.length; x++) {
  var m = String(seasons[x].id || "").match(/^S(\d+)$/);
  if (m) {
    var n = Number(m[1]);
    if (n > maxNum) maxNum = n;
  }
}
var newId = "S" + (maxNum + 1);

  seasons.push({
  id: newId,
  name: newId,
  startAt: Date.now(),
  endAt: null,
  finalRR: null,
  finalRankLabel: null,
  stats: null
});

  saveSeasons(seasons);
  setActiveSeasonId(newId);
  setSelectedSeasonId(newId);

  lastRankState = null;
  renderHistoryFromStorage();

  alert("New season started! RR has been reset for the active season.");
}
  
  function clampNumber(val, min, max, fallback) {
  val = Number(val);
  if (!isFinite(val)) return fallback;
  if (val < min) return min;
  if (val > max) return max;
  return val;
}
  
  function genMatchId(ts) {
  // Unique-enough ID without crypto dependency
  var r = Math.random().toString(16).slice(2);
  return "m_" + String(ts) + "_" + r;
}
  
  function enforceActiveSeasonContext() {
  ensureSeasonSystem();

  var activeId = getActiveSeasonId();
  var selectedId = getSelectedSeasonId();

  if (selectedId && activeId && selectedId !== activeId) {
    setSelectedSeasonId(activeId);
    return false;
  }
  return true;
}
  
  function submitMatch() {
    // Lock RP: prevent adding match while viewing past season
  var okSeason = enforceActiveSeasonContext();
  if (!okSeason) {
    showToast("Switched back to ACTIVE season. Please submit again.", "warn");
    renderHistoryFromStorage();
    return;
  }
   
  const place = clampNumber(document.getElementById("inPlace").value, 1, 25, 25);
  const kills = clampNumber(document.getElementById("inKills").value, 0, 99, 0);
  const assists = clampNumber(document.getElementById("inAssists").value, 0, 99, 0);
  const deaths = clampNumber(document.getElementById("inDeaths").value, 0, 99, 0);
  var mvp = document.getElementById("inMVP").checked;
  var left = document.getElementById("inLeft").checked;
  document.getElementById("inPlace").value = place;
  document.getElementById("inKills").value = kills;
  document.getElementById("inAssists").value = assists;
  document.getElementById("inDeaths").value = deaths;

  var ts = Date.now();
    
  var match = { place: place, kills: kills, assists: assists, deaths: deaths, mvp: mvp, left: left, ts: ts, seasonId: getActiveSeasonId(), matchId: genMatchId(ts) };
  match.breakdown = calcRPBreakdown(match);
  match.rp = match.breakdown.total;

  var matches = loadMatches();
  matches.push(match);
  saveMatches(matches);
    document.getElementById("inKills").value = 0;
    document.getElementById("inAssists").value = 0;
    document.getElementById("inDeaths").value = 1;
    document.getElementById("inMVP").checked = false;
    document.getElementById("inLeft").checked = false;

  renderHistoryFromStorage();

  var btns = document.querySelectorAll(".nav-btn");
  showTab("history", btns[2]);
}

function undoLastMatch() {
  ensureSeasonSystem();

  var activeSeasonId = getActiveSeasonId();
  var matches = loadMatches();

  if (!matches || matches.length === 0) {
    alert("No matches to undo.");
    return;
  }

  // Find newest match ONLY in active season
  var newestIndex = -1;
  var newestTs = -Infinity;

  for (var i = 0; i < matches.length; i++) {
    if (matches[i].seasonId !== activeSeasonId) continue;

    var ts = Number(matches[i].ts || 0);
    if (ts > newestTs) {
      newestTs = ts;
      newestIndex = i;
    }
  }

  if (newestIndex === -1) {
    alert("No matches to undo in the active season.");
    return;
  }

  matches.splice(newestIndex, 1);
  saveMatches(matches);

  lastRankState = null;
  renderHistoryFromStorage();

  var btns = document.querySelectorAll(".nav-btn");
  showTab("history", btns[2]);
}

function resetMatches() {
  if (!confirm("Reset all saved matches?")) return;
  localStorage.removeItem(STORAGE_KEY);
  lastRankState = null;
  renderHistoryFromStorage();
}

  document.addEventListener("click", function(e){
  var t = e.target;
  if (t && t.id === "toggleHistoryBtn") {
    var mode = getHistoryLimit();
    setHistoryLimit(mode === "all" ? "20" : "all");
    renderHistoryFromStorage();
  }
});
  
  document.addEventListener("change", function(e){
  var t = e.target;
  if (t && t.id === "seasonSelect") {
    setSelectedSeasonId(t.value);
    lastRankState = null;
    ensureSeasonSystem();
    renderHistoryFromStorage();
  }
});
function exportData() {
  ensureSeasonSystem();

  var box = document.getElementById("ioBox");

  var payload = {
    version: 2,
    exportedAt: Date.now(),
    seasons: loadSeasons(),
    activeSeasonId: getActiveSeasonId(),
    selectedSeasonId: getSelectedSeasonId(),
    matches: loadMatches()
  };

  var json = JSON.stringify(payload, null, 2);
  if (box) box.value = json;

  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(json).then(function () {
      alert("Exported! Full data copied to clipboard.");
    }).catch(function () {
      alert("Exported! (Clipboard copy was blocked by browser.)");
    });
  } else {
    alert("Exported! (Clipboard API not available.)");
  }
}

function importData() {
  ensureSeasonSystem();

  var box = document.getElementById("ioBox");
  if (!box) {
    alert("Import box not found.");
    return;
  }

  var text = String(box.value || "").trim();
  if (!text) {
    alert("Paste JSON into the box first.");
    return;
  }

  var payload;
  try {
    payload = JSON.parse(text);
  } catch (e) {
    alert("Invalid JSON. Please check formatting.");
    return;
  }

  var seasons = null;
  var activeId = null;
  var selectedId = null;
  var matches = null;

  if (payload && payload.version === 2) {
    seasons = Array.isArray(payload.seasons) ? payload.seasons : null;
    activeId = payload.activeSeasonId;
    selectedId = payload.selectedSeasonId;
    matches = Array.isArray(payload.matches) ? payload.matches : null;
  } else if (Array.isArray(payload)) {
    matches = payload;
  } else if (payload && Array.isArray(payload.matches)) {
    matches = payload.matches;
  }

  if (!matches) {
    alert("Unsupported format. Must be v2 export or { matches: [...] }");
    return;
  }

  if (!seasons || seasons.length === 0 || !activeId) {
    // legacy import: create single season
    activeId = "S1";
    seasons = [{
      id: activeId,
      startAt: Date.now(),
      endAt: null,
      finalRR: null,
      finalRankLabel: null,
      stats: null
    }];
    selectedId = activeId;
  }

  // Clean + normalize matches (ensure seasonId, ts, rp/breakdown)
  var cleaned = [];
  for (var i = 0; i < matches.length; i++) {
    var m = matches[i] || {};

    var place = clampInt(m.place, 1, 25, 25);
    var kills = clampInt(m.kills, 0, 99, 0);
    var assists = clampInt(m.assists, 0, 99, 0);
    var deaths = clampInt(m.deaths, 0, 99, 0);
    var mvp = !!m.mvp;
    var left = !!m.left;
    var ts = Number(m.ts || Date.now());
    var seasonId = m.seasonId ? String(m.seasonId) : String(activeId);

    if (!isFinite(place)) place = 25;
    if (!isFinite(kills)) kills = 0;
    if (!isFinite(assists)) assists = 0;
    if (!isFinite(deaths)) deaths = 0;
    if (!isFinite(ts)) ts = Date.now();

    var obj = {
      place: place,
      kills: kills,
      assists: assists,
      deaths: deaths,
      mvp: mvp,
      left: left,
      ts: ts,
      seasonId: seasonId
    };

    obj.breakdown = calcRPBreakdown(obj);
    obj.rp = obj.breakdown.total;

    cleaned.push(obj);
  }
  
  makeBackup("before import");
  if (!confirm("Import will replace your current saved data (seasons + matches). Continue?")) return;

  saveMatches(cleaned);
  saveSeasons(seasons);

  setActiveSeasonId(activeId);

  var validSelected = false;
  for (var s = 0; s < seasons.length; s++) {
    if (seasons[s].id === selectedId) validSelected = true;
  }
  setSelectedSeasonId(validSelected ? selectedId : activeId);

  lastRankState = null;
  renderHistoryFromStorage();

  var btns = document.querySelectorAll(".nav-btn");
  showTab("history", btns[2]);

  alert("Import complete!");
}

function clearIO() {
  var box = document.getElementById("ioBox");
  if (box) box.value = "";
}
  function renameSeason() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var selectedId = getSelectedSeasonId();

  var season = null;
  for (var i = 0; i < seasons.length; i++) {
    if (seasons[i].id === selectedId) season = seasons[i];
  }
  if (!season) {
    alert("Season not found.");
    return;
  }

  var currentName = season.name || season.id;
  var next = prompt("Enter season name:", currentName);
  if (next === null) return;

  next = String(next).trim();
  if (!next) {
    alert("Name cannot be empty.");
    return;
  }
  if (next.length > 40) {
    alert("Name too long (max 40 chars).");
    return;
  }

  season.name = next;
  saveSeasons(seasons);
  renderHistoryFromStorage();
}

function deleteSeason() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var selectedId = getSelectedSeasonId();
  var activeId = getActiveSeasonId();

  if (selectedId === activeId) {
    alert("You can't delete the active season. Start a new season first, then delete the old one.");
    return;
  }

  // Only allow deleting ended seasons (safety)
  var season = null;
  for (var i = 0; i < seasons.length; i++) {
    if (seasons[i].id === selectedId) season = seasons[i];
  }
  if (!season) {
    alert("Season not found.");
    return;
  }
  if (!season.endAt) {
    alert("You can only delete ended seasons.");
    return;
  }

  if (!confirm("Delete season " + selectedId + " and all its matches? This cannot be undone.")) return;

  // Remove season
  var nextSeasons = [];
  for (var s = 0; s < seasons.length; s++) {
    if (seasons[s].id !== selectedId) nextSeasons.push(seasons[s]);
  }
  saveSeasons(nextSeasons);

  // Remove matches for that season
  var matches = loadMatches();
  var kept = [];
  for (var m = 0; m < matches.length; m++) {
    if (matches[m].seasonId !== selectedId) kept.push(matches[m]);
  }
  saveMatches(kept);

  // After delete, set selected season back to active
  setSelectedSeasonId(activeId);

  lastRankState = null;
  renderHistoryFromStorage();

  alert("Season deleted.");
}
  function renumberSeasonIds() {
  ensureSeasonSystem();

  var seasons = loadSeasons();
  var matches = loadMatches();

  if (!seasons || seasons.length === 0) {
    alert("No seasons found.");
    return;
  }

  if (!confirm("This will rename season IDs to S1, S2, S3... and update all matches. Continue?")) return;

  // Sort seasons by start time (oldest first)
  seasons.sort(function(a, b) {
    return Number(a.startAt || 0) - Number(b.startAt || 0);
  });

  // Build mapping oldId -> newId
  var map = {};
  for (var i = 0; i < seasons.length; i++) {
    var oldId = seasons[i].id;
    var newId = "S" + (i + 1);
    map[oldId] = newId;

    seasons[i].id = newId;

    // Default name if empty
    if (!seasons[i].name) seasons[i].name = newId;
  }

  // Update matches seasonId
  for (var m = 0; m < matches.length; m++) {
    var old = matches[m].seasonId;
    if (old && map[old]) matches[m].seasonId = map[old];
  }

  // Update active/selected IDs
  var activeOld = getActiveSeasonId();
  var selectedOld = getSelectedSeasonId();

  if (activeOld && map[activeOld]) setActiveSeasonId(map[activeOld]);
  if (selectedOld && map[selectedOld]) setSelectedSeasonId(map[selectedOld]);

  saveSeasons(seasons);
  saveMatches(matches);

  lastRankState = null;
  renderHistoryFromStorage();

  alert("Season IDs renumbered successfully.");
}
  document.addEventListener("click", function(e){
  var t = e.target;
    // Edit match button (active season)
if (t && t.getAttribute && t.getAttribute("data-edit-id")) {
  var idEdit = String(t.getAttribute("data-edit-id") || "");
  if (!idEdit) return;

  ensureSeasonSystem();
  var activeId = getActiveSeasonId();

  var matches = loadMatches();
  var found = null;
  for (var i = 0; i < matches.length; i++) {
    if (matches[i].seasonId === activeId && String(matches[i].matchId) === idEdit) {
      found = matches[i];
      break;
    }
  }

  if (!found) {
    alert("Match not found (or not in active season).");
    return;
  }

  // Fill form inputs
  document.getElementById("inPlace").value = found.place;
  document.getElementById("inKills").value = found.kills;
  document.getElementById("inAssists").value = found.assists;
  document.getElementById("inDeaths").value = found.deaths;
  document.getElementById("inMVP").checked = !!found.mvp;
  document.getElementById("inLeft").checked = !!found.left;

  editingMatchId = found.ts;

  var saveBtn = document.getElementById("saveEditBtn");
  if (saveBtn) saveBtn.style.display = "inline-block";

  // Go to ADD tab
  var btns = document.querySelectorAll(".nav-btn");
  showTab("add", btns[3]);

  return;
}

  // Delete match button
  if (t && t.classList && t.classList.contains("btn-mini") && t.classList.contains("danger") && t.getAttribute("data-ts")) {
    var ts = Number(t.getAttribute("data-ts"));
    if (!isFinite(ts)) return;

    ensureSeasonSystem();
    var activeId = getActiveSeasonId();
    
    makeBackup("before delete match");
    if (!confirm("Delete this match from the active season? This cannot be undone.")) return;

    var matches = loadMatches();
    var kept = [];
    var removed = false;

    for (var i = 0; i < matches.length; i++) {
      // Only allow deleting from active season
      if (matches[i].seasonId === activeId && Number(matches[i].ts) === ts) {
        removed = true;
        continue;
      }
      kept.push(matches[i]);
    }

    if (!removed) {
      alert("Match not found (or not in active season).");
      return;
    }

    saveMatches(kept);
    lastRankState = null;
    renderHistoryFromStorage();
  }
});
  
  preloadRankBadges();
  
/* ===== INIT ===== */
renderHistoryFromStorage();
</script>
  <!-- ===== END OF JAVASCRIPT ===== -->

<!-- ===== END OF UI ===== -->
</body>
</html>
